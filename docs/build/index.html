<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Welcome Page · GenX</title><link rel="canonical" href="https://genxproject.github.io/GenX/index.html"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GenX</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href="index.html">Welcome Page</a><ul class="internal"><li><a class="tocitem" href="#Overview-1"><span>Overview</span></a></li><li><a class="tocitem" href="#Requirements-1"><span>Requirements</span></a></li><li><a class="tocitem" href="#Documentation-1"><span>Documentation</span></a></li><li><a class="tocitem" href="#Running-an-Instance-of-GenX-1"><span>Running an Instance of GenX</span></a></li><li><a class="tocitem" href="#Contents-1"><span>Contents</span></a></li><li><a class="tocitem" href="#Index-1"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="load-inputs.html">Load Inputs</a></li><li><span class="tocitem">Model Components</span><ul><li><a class="tocitem" href="discharge.html">Discharge</a></li><li><a class="tocitem" href="non-served-energy.html">Non Served Energy</a></li><li><a class="tocitem" href="reserves.html">Reserves</a></li><li><a class="tocitem" href="ucommit.html">Unit Commitment</a></li></ul></li><li><span class="tocitem">Resources</span><ul><li><a class="tocitem" href="curtailable-variable-renewable.html">Curtailable Variable Renewable</a></li><li><a class="tocitem" href="flexible-demand.html">Flexible Demand</a></li><li><a class="tocitem" href="hydro-res.html">Hydro</a></li><li><a class="tocitem" href="must-run.html">Must Run</a></li><li><a class="tocitem" href="thermal-commit.html">Thermal Commit</a></li><li><a class="tocitem" href="thermal-no-commit.html">Thermal No Commit</a></li></ul></li><li><span class="tocitem">Methods</span><ul><li><a class="tocitem" href="time-domain-reduction.html">Time Domain Reduction</a></li></ul></li><li><a class="tocitem" href="data-documentation.html">GenX Data</a></li><li><a class="tocitem" href="write-outputs.html">GenX Outputs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="index.html">Welcome Page</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="index.html">Welcome Page</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/GenXProject/GenX/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="GenX-Documentation-1"><a class="docs-heading-anchor" href="#GenX-Documentation-1">GenX Documentation</a><a class="docs-heading-anchor-permalink" href="#GenX-Documentation-1" title="Permalink"></a></h1><h2 id="Overview-1"><a class="docs-heading-anchor" href="#Overview-1">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-1" title="Permalink"></a></h2><p>GenX is a highly-configurable electricity resource capacity expansion model that incorporates several state-of-the-art practices in electricity system planning to offer improved decision support for a changing electricity landscape. GenX is a constrained optimization model that determines the mix of electricity generation, storage, transmission, and demand-side resource investments and operational decisions to meet electricity demand in one or more future planning years at lowest cost subject to a variety of power system operational constraints and specified policy constraints, such as CO<span>$_2$</span> emissions limits. Importantly, GenX can be configured with varying level of model resolution and scope, with regards to chronological variability of electricity demand and renewable energy availability, power system operational detail and unit commitment constraints, and transmission and distribution network representation, depending on the planning problem or policy question to be studied. As such, the GenX model is designed to be highly configurable, with several different degrees of resolution possible on each of these key dimensions. The model is capable of representing a full range of conventional and novel electricity resources, including thermal generators, variable renewable resources (wind and solar), run-of-river, reservoir and pumped-storage hydroelectric generators, energy storage devices, demand-side flexibility, and several advanced technologies such as long-duration energy storage and thermal plants with flexible carbon capture and storage.</p><h2 id="Requirements-1"><a class="docs-heading-anchor" href="#Requirements-1">Requirements</a><a class="docs-heading-anchor-permalink" href="#Requirements-1" title="Permalink"></a></h2><p>GenX runs on Julia v1.3.1 and JuMP v0.21.4, and requires a valid Gurobi license on the host machine. Note that this is an older JuMP distribution. If you have a different version of JuMP installed in your Julia environment, you can install JuMP v0.21.4 by running the command <code>pkg&gt; add JuMP@0.21.4</code> in the Julia package manager (you can access the Julia package manager by running the command <code>julia&gt; ]</code> in the Julia command prompt). GenX.jl requires the following Julia packages:</p><ul><li>CSV (v0.5.23)</li><li>DataFrames (v0.20.2)</li><li>Gurobi (v0.7.6)</li><li>JuMP (v0.21.4)</li><li>LinearAlgebra</li><li>MathProgBase (v0.7.8)</li><li>StatsBase (v0.33.0)</li><li>YAML (v0.4.3)</li><li>Documenter (v0.24.7)</li><li>DocumenterTools (v0.1.9)</li></ul><p>You can see all of the packages installed in your Julia environment and their version numbers by running pkg&gt; status on the package manager command line.</p><h2 id="Documentation-1"><a class="docs-heading-anchor" href="#Documentation-1">Documentation</a><a class="docs-heading-anchor-permalink" href="#Documentation-1" title="Permalink"></a></h2><p>Detailed documentation for GenX can be found <a href="https://docs.google.com/document/d/1G_1gdnSj92jF8nda2Zl8O4M5B98t19gOYnbbMFhohb4/edit?usp=sharing">here</a>. It includes details of each of GenX&#39;s methods, required and optional input files, and outputs.  Documentation for <a href="https://github.com/GenXProject/GenX">GenX</a>.</p><h2 id="Running-an-Instance-of-GenX-1"><a class="docs-heading-anchor" href="#Running-an-Instance-of-GenX-1">Running an Instance of GenX</a><a class="docs-heading-anchor-permalink" href="#Running-an-Instance-of-GenX-1" title="Permalink"></a></h2><p>The Run<em>test.jl file provides an example of how to use GenX.jl for capacity expansion modeling. The following are the main steps performed in the Run</em>test.jl script: 1.	Specify input parameters 2.	Instantiate a Gurobi Solver instance 3.	Load the model inputs from a specified directory 4.	Generate a GenX model 5.	Solve the model 6.	Write the output files to a specified directory</p><p>Here are step by step instructions for running Run<em>test.jl: 1.	Start an instance of the Julia kernel. 2.	Make your present working directory the directory which contains Run</em>test.jl. To do this, you can use the Julia command <code>julia&gt; cd(“/path/to/directory/containing/GenX”)</code>, using the pathname of the directory containing Run<em>test.jl. Note that GenX.jl, as well as a folder containing your inputs files, should be in this directory in addition to Run</em>test.jl. Details about the required input files can be found below. You can check your present working directory by running the command <code>julia&gt; pwd()</code>. 3.	Run the script by executing the command <code>julia&gt; include(“Run_test.jl”)</code>. 4.	After the script runs to completion, results will be written to a folder called “Results”</p><p>Note that if you have not already installed the required Julia packages, you are using a version of JuMP other than v0.18.6, or you do not have a valid Gurobi license on your host machine, you will receive an error message and Run_test.jl will not run to completion.</p><h2 id="Contents-1"><a class="docs-heading-anchor" href="#Contents-1">Contents</a><a class="docs-heading-anchor-permalink" href="#Contents-1" title="Permalink"></a></h2><ul><li><a href="curtailable-variable-renewable.html#Curtailable-Variable-Renewables-1">Curtailable Variable Renewables</a></li><li><a href="data-documentation.html#GenX-Database-Documentation-1">GenX Database Documentation</a></li><ul><li><a href="data-documentation.html#Model-setup-parameters-1">1 Model setup parameters</a></li><li><a href="data-documentation.html#Inputs-1">2 Inputs</a></li><li><a href="data-documentation.html#Outputs-1">3 Outputs</a></li><li><a href="data-documentation.html#Running-GenX-1">4 Running GenX</a></li></ul><li><a href="discharge.html#Discharge-1">Discharge</a></li><li><a href="flexible-demand.html#Flexible-Demand-1">Flexible Demand</a></li><li><a href="hydro-res.html#Hydro-Resources-1">Hydro Resources</a></li><li><a href="index.html#GenX-Documentation-1">GenX Documentation</a></li><ul><li><a href="index.html#Overview-1">Overview</a></li><li><a href="index.html#Requirements-1">Requirements</a></li><li><a href="index.html#Documentation-1">Documentation</a></li><li><a href="index.html#Running-an-Instance-of-GenX-1">Running an Instance of GenX</a></li><li><a href="index.html#Contents-1">Contents</a></li><li><a href="index.html#Index-1">Index</a></li></ul><li><a href="load-inputs.html#Reading-Input-Files-1">Reading Input Files</a></li><ul><li><a href="load-inputs.html#Capacity-Reserve-Margin-1">Capacity Reserve Margin</a></li><li><a href="load-inputs.html#CO_2-Emissions-Cap-1"><span>$CO_2$</span> Emissions Cap</a></li><li><a href="load-inputs.html#Energy-Share-Requirement-1">Energy Share Requirement</a></li><li><a href="load-inputs.html#Fuels-Data-1">Fuels Data</a></li><li><a href="load-inputs.html#Generators-Input-Data-1">Generators Input Data</a></li><li><a href="load-inputs.html#Variability-of-Generators&#39;-Outputs-1">Variability of Generators&#39; Outputs</a></li><li><a href="load-inputs.html#Load-Data-1">Load Data</a></li><li><a href="load-inputs.html#Minimum-Capacity-Requirements-1">Minimum Capacity Requirements</a></li><li><a href="load-inputs.html#Transmission-Network-1">Transmission Network</a></li><li><a href="load-inputs.html#Mapping-Representative-Time-Periods-1">Mapping Representative Time Periods</a></li><li><a href="load-inputs.html#Reserves-Data-1">Reserves Data</a></li></ul><li><a href="must-run.html#Must-Run-1">Must Run</a></li><li><a href="non-served-energy.html#Non-served-Energy-1">Non-served Energy</a></li><li><a href="reserves.html#Reserves-1">Reserves</a></li><li><a href="thermal-commit.html#Thermal-Commit-1">Thermal Commit</a></li><li><a href="thermal-no-commit.html#Thermal-No-Commit-1">Thermal No Commit</a></li><li><a href="time-domain-reduction.html#Time-Domain-Reduction-1">Time Domain Reduction</a></li><li><a href="ucommit.html#Unit-Commitment-1">Unit Commitment</a></li><li><a href="write-outputs.html#Functions-for-Writing-the-Different-Results/Outputs-to-Separate-Files-1">Functions for Writing the Different Results/Outputs to Separate Files</a></li><ul><li><a href="write-outputs.html#Write-Status-1">Write Status</a></li><li><a href="write-outputs.html#Write-Costs-1">Write Costs</a></li><li><a href="write-outputs.html#Write-Capacities-1">Write Capacities</a></li><li><a href="write-outputs.html#Write-Charge-Values-1">Write Charge Values</a></li><li><a href="write-outputs.html#Write-Storage-1">Write Storage</a></li><li><a href="write-outputs.html#Write-Power-1">Write Power</a></li><li><a href="write-outputs.html#Write-Curtailment-1">Write Curtailment</a></li></ul></ul><h2 id="Index-1"><a class="docs-heading-anchor" href="#Index-1">Index</a><a class="docs-heading-anchor-permalink" href="#Index-1" title="Permalink"></a></h2><ul><li><a href="index.html#GenX.RemoveConstCols"><code>GenX.RemoveConstCols</code></a></li><li><a href="index.html#GenX.cap_reserve_margin-Tuple{JuMP.Model,Dict,Dict}"><code>GenX.cap_reserve_margin</code></a></li><li><a href="index.html#GenX.check_condition-NTuple{5,Any}"><code>GenX.check_condition</code></a></li><li><a href="index.html#GenX.cluster"><code>GenX.cluster</code></a></li><li><a href="index.html#GenX.cluster_inputs"><code>GenX.cluster_inputs</code></a></li><li><a href="index.html#GenX.co2_cap-Tuple{JuMP.Model,Dict,Dict}"><code>GenX.co2_cap</code></a></li><li><a href="curtailable-variable-renewable.html#GenX.curtailable_variable_renewable_reserves-Tuple{JuMP.Model,Dict}"><code>GenX.curtailable_variable_renewable_reserves</code></a></li><li><a href="discharge.html#GenX.discharge-Tuple{JuMP.Model,Dict}"><code>GenX.discharge</code></a></li><li><a href="index.html#GenX.energy_share_requirement-Tuple{JuMP.Model,Dict,Dict}"><code>GenX.energy_share_requirement</code></a></li><li><a href="flexible-demand.html#GenX.flexible_demand-Tuple{JuMP.Model,Dict}"><code>GenX.flexible_demand</code></a></li><li><a href="index.html#GenX.get_absolute_extreme-NTuple{4,Any}"><code>GenX.get_absolute_extreme</code></a></li><li><a href="index.html#GenX.get_extreme_period"><code>GenX.get_extreme_period</code></a></li><li><a href="index.html#GenX.get_integral_extreme-NTuple{4,Any}"><code>GenX.get_integral_extreme</code></a></li><li><a href="index.html#GenX.get_worst_period_idx-Tuple{Any}"><code>GenX.get_worst_period_idx</code></a></li><li><a href="hydro-res.html#GenX.hydro_res-Tuple{JuMP.Model,Dict,Int64}"><code>GenX.hydro_res</code></a></li><li><a href="hydro-res.html#GenX.hydro_res_reserves-Tuple{JuMP.Model,Dict}"><code>GenX.hydro_res_reserves</code></a></li><li><a href="index.html#GenX.investment_charge-Tuple{JuMP.Model,Dict}"><code>GenX.investment_charge</code></a></li><li><a href="index.html#GenX.investment_energy-Tuple{JuMP.Model,Dict}"><code>GenX.investment_energy</code></a></li><li><a href="index.html#GenX.load_cap_reserve_margin-Tuple{Dict,AbstractString,AbstractString,Dict,DataFrames.DataFrame}"><code>GenX.load_cap_reserve_margin</code></a></li><li><a href="index.html#GenX.load_co2_cap-Tuple{Dict,AbstractString,AbstractString,Dict}"><code>GenX.load_co2_cap</code></a></li><li><a href="index.html#GenX.load_data-Tuple{Dict,AbstractString,AbstractString,Dict}"><code>GenX.load_data</code></a></li><li><a href="index.html#GenX.load_energy_share_requirement-Tuple{Dict,AbstractString,AbstractString,Dict}"><code>GenX.load_energy_share_requirement</code></a></li><li><a href="index.html#GenX.load_fuels_data-Tuple{Dict,AbstractString,AbstractString,Dict}"><code>GenX.load_fuels_data</code></a></li><li><a href="index.html#GenX.load_generators_data-Tuple{Dict,AbstractString,AbstractString,Dict,Dict,Dict}"><code>GenX.load_generators_data</code></a></li><li><a href="index.html#GenX.load_generators_variability-Tuple{Dict,AbstractString,AbstractString,Dict}"><code>GenX.load_generators_variability</code></a></li><li><a href="index.html#GenX.load_inputs-Tuple{Dict,AbstractString}"><code>GenX.load_inputs</code></a></li><li><a href="index.html#GenX.load_minimum_capacity_requirement-Tuple{AbstractString,AbstractString,Dict,Dict}"><code>GenX.load_minimum_capacity_requirement</code></a></li><li><a href="index.html#GenX.load_network_data-Tuple{Dict,AbstractString,AbstractString,Dict}"><code>GenX.load_network_data</code></a></li><li><a href="index.html#GenX.load_period_map-Tuple{Dict,AbstractString,AbstractString,Dict}"><code>GenX.load_period_map</code></a></li><li><a href="index.html#GenX.load_reserves-Tuple{Dict,AbstractString,AbstractString,Dict}"><code>GenX.load_reserves</code></a></li><li><a href="index.html#GenX.long_duration_storage-Tuple{JuMP.Model,Dict}"><code>GenX.long_duration_storage</code></a></li><li><a href="index.html#GenX.minimum_capacity_requirement-Tuple{JuMP.Model,Dict}"><code>GenX.minimum_capacity_requirement</code></a></li><li><a href="index.html#GenX.must_run-Tuple{JuMP.Model,Dict}"><code>GenX.must_run</code></a></li><li><a href="index.html#GenX.non_served_energy-Tuple{JuMP.Model,Dict}"><code>GenX.non_served_energy</code></a></li><li><a href="index.html#GenX.parse_data-Tuple{Any}"><code>GenX.parse_data</code></a></li><li><a href="index.html#GenX.reserves-Tuple{JuMP.Model,Dict,Int64}"><code>GenX.reserves</code></a></li><li><a href="index.html#GenX.reserves_contingency-Tuple{JuMP.Model,Dict,Int64}"><code>GenX.reserves_contingency</code></a></li><li><a href="index.html#GenX.rmse_score-Tuple{Any,Any}"><code>GenX.rmse_score</code></a></li><li><a href="index.html#GenX.scale_weights"><code>GenX.scale_weights</code></a></li><li><a href="index.html#GenX.storage_asymmetric_reserves-Tuple{JuMP.Model,Dict}"><code>GenX.storage_asymmetric_reserves</code></a></li><li><a href="index.html#GenX.storage_symmetric_reserves-Tuple{JuMP.Model,Dict}"><code>GenX.storage_symmetric_reserves</code></a></li><li><a href="index.html#GenX.thermal_commit-Tuple{JuMP.Model,Dict,Int64}"><code>GenX.thermal_commit</code></a></li><li><a href="index.html#GenX.thermal_commit_reserves-Tuple{JuMP.Model,Dict}"><code>GenX.thermal_commit_reserves</code></a></li><li><a href="index.html#GenX.thermal_no_commit-Tuple{JuMP.Model,Dict,Int64}"><code>GenX.thermal_no_commit</code></a></li><li><a href="index.html#GenX.thermal_no_commit_reserves-Tuple{JuMP.Model,Dict}"><code>GenX.thermal_no_commit_reserves</code></a></li><li><a href="index.html#GenX.transmission-Tuple{JuMP.Model,Dict,Int64,Int64}"><code>GenX.transmission</code></a></li><li><a href="index.html#GenX.ucommit-Tuple{JuMP.Model,Dict,Int64}"><code>GenX.ucommit</code></a></li><li><a href="index.html#GenX.write_capacity-Tuple{AbstractString,AbstractString,Dict,Dict,JuMP.Model}"><code>GenX.write_capacity</code></a></li><li><a href="index.html#GenX.write_charge-Tuple{AbstractString,AbstractString,Dict,Dict,JuMP.Model}"><code>GenX.write_charge</code></a></li><li><a href="index.html#GenX.write_costs-Tuple{AbstractString,AbstractString,Dict,Dict,JuMP.Model}"><code>GenX.write_costs</code></a></li><li><a href="index.html#GenX.write_curtailment-Tuple{AbstractString,AbstractString,Dict,Dict,JuMP.Model}"><code>GenX.write_curtailment</code></a></li><li><a href="index.html#GenX.write_outputs-Tuple{JuMP.Model,AbstractString,Dict,Dict}"><code>GenX.write_outputs</code></a></li><li><a href="index.html#GenX.write_power-Tuple{AbstractString,AbstractString,Dict,Dict,JuMP.Model}"><code>GenX.write_power</code></a></li><li><a href="index.html#GenX.write_status-Tuple{AbstractString,AbstractString,Dict,JuMP.Model}"><code>GenX.write_status</code></a></li><li><a href="index.html#GenX.write_storage-Tuple{AbstractString,AbstractString,Dict,Dict,JuMP.Model}"><code>GenX.write_storage</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="GenX.cluster_inputs" href="#GenX.cluster_inputs"><code>GenX.cluster_inputs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cluster_inputs(inpath, v=false, norm_plot=false, silh_plot=false, res_plots=false, indiv_plots=false, pair_plots=false)</code></pre><p>Use kmeans or kemoids to cluster raw load profiles and resource capacity factor profiles into representative periods. Use Extreme Periods to capture noteworthy periods or periods with notably poor fits.</p><p>Inputs</p><p>In Load_data.csv, include the following:</p><ul><li>Timesteps<em>per</em>Rep_Period - Typically 168 timesteps (e.g., hours) per period, this designates the length   of each representative period.</li><li>UseExtremePeriods - Either 1 or 0, this designates whether or not to include  outliers (by performance or load/resource extreme) as their own representative periods.  This setting automatically includes the periods with maximum load, minimum solar cf and  minimum wind cf as extreme periods.</li><li>ClusterMethod - Either &#39;kmeans&#39; or &#39;kmedoids&#39;, this designates the method used to cluster  periods and determine each point&#39;s representative period.</li><li>ScalingMethod - Either &#39;N&#39; or &#39;S&#39;, this designates directs the module to normalize ([0,1])  or standardize (mean 0, variance 1) the input data.</li><li>MinPeriods - The minimum number of periods used to represent the input data. If using  UseExtremePeriods, this must be at least three. If IterativelyAddPeriods if off,  this will be the total number of periods.</li><li>MaxPeriods - The maximum number of periods - both clustered periods and extreme periods -  that may be used to represent the input data.</li><li>IterativelyAddPeriods - Either 1 or 0, this designates whether or not to add periods  until the error threshold between input data and represented data is met or the maximum  number of periods is reached.</li><li>Threshold - Iterative period addition will end if the period farthest (Euclidean Distance)  from its representative period is within this percentage of the total possible error (for normalization)  or ~95% of the total possible error (for standardization). E.g., for a threshold of 0.01,  every period must be within 1% of the spread of possible error before the clustering  iterations will terminate (or until the max number of periods is reached).</li><li>IterateMethod - Either &#39;cluster&#39; or &#39;extreme&#39;, this designates whether to add clusters to  the kmeans/kmedoids method or to set aside the worst-fitting periods as a new extreme periods.</li><li>nReps - The number of times to repeat each kmeans/kmedoids clustering at the same setting.</li><li>LoadWeight - Default 1, this is an optional multiplier on load columns in order to prioritize  better fits for load profiles over resource capacity factor profiles.</li><li>WeightTotal - Default 8760, the sum to which the relative weights of representative periods will be scaled.</li><li>ClusterFuelPrices - Either 1 or 0, this indicates whether or not to use the fuel price  time series in Fuels<em>data.csv in the clustering process. If &#39;no&#39;, this function will still write  Fuels</em>data_clustered.csv with reshaped fuel prices based on the number and size of the  representative weeks, assuming a constant time series of fuel prices with length equal to the  number of timesteps in the raw input data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/time_domain_reduction/time_domain_reduction.jl#L394-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.load_inputs-Tuple{Dict,AbstractString}" href="#GenX.load_inputs-Tuple{Dict,AbstractString}"><code>GenX.load_inputs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_inputs(setup::Dict,path::AbstractString)</code></pre><p>Loads various data inputs from multiple input .csv files in path directory and stores variables in a Dict (dictionary) object for use in model() function</p><p>inputs: setup - dict object containing setup parameters path - string path to working directory</p><p>returns: Dict (dictionary) object containing all data inputs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/load_inputs/load_inputs.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.write_outputs-Tuple{JuMP.Model,AbstractString,Dict,Dict}" href="#GenX.write_outputs-Tuple{JuMP.Model,AbstractString,Dict,Dict}"><code>GenX.write_outputs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_outputs(EP::Model, path::AbstractString, setup::Dict, inputs::Dict)</code></pre><p>Function for the entry-point for writing the different output files. From here, onward several other functions are called, each for writing specific output files, like costs, capacities, etc. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/write_outputs/write_outputs.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.RemoveConstCols" href="#GenX.RemoveConstCols"><code>GenX.RemoveConstCols</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">RemoveConstCols(all_profiles, all_col_names)</code></pre><p>Remove and store the columns that do not vary during the period.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/time_domain_reduction/time_domain_reduction.jl#L240-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.cap_reserve_margin-Tuple{JuMP.Model,Dict,Dict}" href="#GenX.cap_reserve_margin-Tuple{JuMP.Model,Dict,Dict}"><code>GenX.cap_reserve_margin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cap_reserve_margin(EP::Model, inputs::Dict, setup::Dict)</code></pre><p>Instead of modeling capacity reserve margin requirement (a.k.a. capacity market or resource adequacy requirement) using an annual constraint, we model each requirement with hourly constraint by simulating the activation of the capacity obligation (Eq. \ref{eq:CRM}). We define capacity reserve margin constraint for subsets of zones,<span>$z  \in \mathcal{Z}^{CRM}_{p}$</span>, and each subset stands for a locational deliverability area (LDA) or a reserve sharing group.  For thermal resources, the available capacity is the total capacity in the LDA derated by the outage rate, <span>$\epsilon_{y,z,p}^{CRM}$</span>. For storage (<span>$y \in \mathcal{O}$</span>), variable renewable energy (<span>$y \in \mathcal{VRE}$</span>), and  flexibile demand resources (<span>$y \in \mathcal{DF}$</span>), the available capacity is the net injection into the transmission network in time step <span>$t$</span> derated by the derating factor, also stored in the parameter, <span>$\epsilon_{y,z,p}^{CRM}$</span>. If the imported capacity is eligible to provide capacity to the CRM constraint, the inbound powerflow on all lines <span>$\mathcal{L}_{p}^{in}$</span> in time step <span>$t$</span> will be derated to form the available capacity from outside of the LDA. The reverse is true as well: the outbound derated powerflow on all lines <span>$\mathcal{L}_{p}^{out}$</span> in time step <span>$t$</span> is taken out from the total available capacity. The derating factor should be equal to the expected availability of the resource during periods when the capacity reserve constraint is binding (e.g. accounting for forced outages during supply constrained periods) and is similar to derating factors used in the capacity markets. On top of the flexible demand resources, load curtailment can also provide capacity (i.e., demand response or load management). We allow all segments of voluntary load curtailment, <span>$s \geq 2 \in S$</span>, to contribute to capacity requirements. The first segment <span>$s = 1 \in S$</span> corresponds to involuntary demand curtailment or emergency load shedding at the price cap or value of lost load, and thus does not contribute to reserve requirements.  Note that the time step-weighted sum of the shadow prices of this constraint corresponds to the capacity market payments reported by ISOs with mandate capacity market mechanism.</p><div>\[\begin{aligned}
\label{eq:CRM}
   &amp; \sum_{z  \in \mathcal{Z}^{CRM}_{p}} \Big( \sum_{y \in \mathcal{H}} \epsilon_{y,z,p}^{CRM} \times \Delta^{\text{total}}_{y,z} + \sum_{y \in \mathcal{VRE}} \epsilon_{y,z,p}^{CRM} \times \Theta_{y,z,t} \\
   + &amp; \sum_{y \in \mathcal{O}} \epsilon_{y,z,p}^{CRM} \times \left(\Theta_{y,z,t} - \Pi_{y,z,t} \right) + \sum_{y \in \mathcal{DF}} \epsilon_{y,z,p}^{CRM} \times \left(\Pi_{y,z,t} - \Theta_{y,z,t} \right) \\
   + &amp; \sum_{l \in \mathcal{L}_{p}^{in}} \epsilon_{y,z,p}^{CRM} \times \Phi_{l,t} -  \sum_{l \in \mathcal{L}_{p}^{out}} \epsilon_{y,z,p}^{CRM} \times \Phi_{l,t}
   +  \sum_{s \geq 2} \Lambda_{s,t,z}  \Big) \\
   &amp; \geq \sum_{z  \in \mathcal{Z}^{CRM}_{p}} \left( \left(1 + RM_{z,p}^{CRM} \right) \times D_{z,t} \right)  \hspace{1 cm}  \forall t \in \mathcal{T}, \forall p\in \mathcal{P}^{CRM}
\end{aligned}\]</div><p>Note that multiple capacity reserve margin requirements can be specified covering different individual zones or aggregations of zones, where the total number of constraints is specified by the GenX settings parameter &#39;&#39;&#39;CapacityReserveMargin&#39;&#39;&#39; (where this parameter should be an integer value &gt; 0).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/model/policies/cap_reserve_margin.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.check_condition-NTuple{5,Any}" href="#GenX.check_condition-NTuple{5,Any}"><code>GenX.check_condition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_condition(Threshold, R, OldColNames, ScalingMethod, TimestepsPerRepPeriod)</code></pre><p>Check whether the greatest Euclidean deviation in the input data and the clustered representation is within a given proportion of the &quot;maximum&quot; possible deviation.</p><p>(1 for Normalization covers 100%, 4 for Standardization covers ~95%)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/time_domain_reduction/time_domain_reduction.jl#L148-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.cluster" href="#GenX.cluster"><code>GenX.cluster</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cluster(ClusterMethod, ClusteringInputDF, NClusters, nIters)</code></pre><p>Get representative periods using cluster centers from kmeans or kmedoids.</p><p>K-Means: https://juliastats.org/Clustering.jl/dev/kmeans.html</p><p>K-Medoids:  https://juliastats.org/Clustering.jl/stable/kmedoids.html</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/time_domain_reduction/time_domain_reduction.jl#L179-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.co2_cap-Tuple{JuMP.Model,Dict,Dict}" href="#GenX.co2_cap-Tuple{JuMP.Model,Dict,Dict}"><code>GenX.co2_cap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">co2_cap(EP::Model, inputs::Dict, setup::Dict)</code></pre><p>This policy constraints mimics the CO\textsubscript{2} emissions cap and permit trading systems, allowing for emissions trading across each zone for which the cap applies. The constraint <span>$p \in \mathcal{P}^{CO_2}$</span> can be flexibly defined for mass-based or rate-based emission limits for one or more model zones, where zones can trade CO\textsubscript{2} emissions permits and earn revenue based on their CO\textsubscript{2} allowance. Note that if the model is fully linear (e.g. no unit commitment or linearized unit commitment), the dual variable of the emissions constraints can be interpreted as the marginal CO\textsubscript{2} price per tonne associated with the emissions target. Alternatively, for integer model formulations, the marginal CO<span>$_2$</span> price can be obtained after solving the model with fixed integer/binary variables. </p><p>The CO<span>$_2$</span> emissions limit can be defined in one of the following ways: a) a mass-based limit defined in terms of annual CO<span>$_2$</span> emissions budget (in million tonnes of CO2), b) a load-side rate-based limit defined in terms of tonnes CO<span>$_2$</span> per MWh of demand and c) a generation-side rate-based limit defined in terms of tonnes CO<span>$_2$</span> per MWh of generation. </p><p><strong>Mass-based emissions constraint</strong></p><p>Mass-based emission limits are implemented as per Eq. \ref{eq:MassCO2}. For each constraint, <span>$p \in \mathcal{P}^{CO_2}_{mass}$</span>, we define a set of zones <span>$z \in \mathcal{Z}^{CO_2}_{p,mass}$</span> that can trade CO\textsubscript{2} allowance. Input data for each constraint  <span>$p \in \mathcal{P}^{CO_2}_{mass}$</span> requires the CO\textsubscript{2} allowance/ budget for each model zone, <span>$\epsilon^{CO_{2}}_{z,p, mass}$</span>, to be provided in terms of million metric tonnes. For every generator <span>$y$</span>, the parameter <span>$\epsilon_{y,z}^{CO\textsubscript{2}}$</span> reflects the specific <span>$CO_2$</span> emission intensity in tCO\textsubscript{2}/MWh associated with its operation.  The resulting constraint is given as:</p><div>\[\begin{aligned}
\label{eq:MassCO2}
    \sum_{z \in \mathcal{Z}^{CO_2}_{p,mass}} \sum_{y \in \mathcal{G}} \sum_{t \in \mathcal{T}} \left(\epsilon_{y,z}^{CO_2} \times \omega_{t} \times \Theta_{y,z,t} \right) 
   &amp; \leq \sum_{z \in \mathcal{Z}^{CO_2}_{p,mass}} \epsilon^{CO_{2}}_{z,p, mass} \\ \hspace{1 cm}  \forall p \in \mathcal{P}^{CO_2}_{mass}
\end{aligned}\]</div><p>In the above constraint, we include both power discharge and charge term for each resource to account for the potential for CO<span>$_2$</span> emissions (or removal when considering negative emissions technologies) associated with each step. Note that if a limit is applied to each zone separately, then the set <span>$\mathcal{Z}^{CO_2}_{p,mass}$</span> will contain only one zone with no possibility of trading. If a system-wide emission limit constraint is applied, then <span>$\mathcal{Z}^{CO_2}_{p,mass}$</span> will be equivalent to a set of all zones.</p><p><strong>Load-side rate-based emissions constraint</strong></p><p>We modify the right hand side of the above mass-based constraint, <span>$p \in \mathcal{P}^{CO_2}_{load}$</span>, to set emissions target based on a CO<span>$_2$</span> emission rate limit in tCO\textsubscript{2}/MWh <span>$\times$</span> the total demand served in each zone. In the following constraint, total demand served takes into account non-served energy and storage related losses. Here, <span>$\epsilon_{z,p,load}^{maxCO_2}$</span> denotes the emission limit in terms on tCO\textsubscript{2}/MWh.</p><div>\[\begin{aligned}
\label{eq:LoadCO2}
    \sum_{z \in \mathcal{Z}^{CO_2}_{p,load}} \sum_{y \in \mathcal{G}} \sum_{t \in \mathcal{T}} \left(\epsilon_{y,z}^{CO_2} \times \omega_{t} \times \Theta_{y,t,z} \right) 
    \leq &amp; \sum_{z \in \mathcal{Z}^{CO_2}_{p,load}} \sum_{t \in \mathcal{T}}  \left(\epsilon_{z,p,load}^{CO_2} \times  \omega_{t} \times D_{z,t} \right) \\  + &amp; \sum_{z \in \mathcal{Z}^{CO_2}_{p,load}} \sum_{y \in \mathcal{O}}  \sum_{t \in \mathcal{T}} \left(\epsilon_{z,p,load}^{CO_2} \times \omega_{t} \times \left(\Pi_{y,t,z} - \Theta_{y,t,z} \right) \right) \\  - &amp; \sum_{z \in \mathcal{Z}^{CO_2}_{p,load}} \sum_{s \in \mathcal{S} } \sum_{t \in \mathcal{T}}  \left(\epsilon_{z,p,load}^{CO_2} \times \omega_{t} \times \Lambda_{s,z,t}\right) \hspace{1 cm}  \forall p \in \mathcal{P}^{CO_2}_{load}
\end{aligned}\]</div><p><strong>Generator-side emissions rate-based constraint</strong></p><p>Similarly, a generation based emission constraint is defined by setting the emission limit based on the total generation times the carbon emission rate limit in tCO\textsubscript{2}/MWh of the region. The resulting constraint is given as:</p><div>\[\begin{aligned}
\label{eq:genCO2}
\sum_{z \in \mathcal{Z}^{CO_2}_{p,gen}} \sum_{y \in \mathcal{G}} \sum_{t \in \mathcal{T}} &amp; \left(\epsilon_{y,z}^{CO_2} \times \omega_{t} \times \Theta_{y,t,z} \right) \\
    \leq \sum_{z \in \mathcal{Z}^{CO_2}_{p,gen}} \sum_{y \in \mathcal{G}} \sum_{t \in \mathcal{T}} &amp; \left(\epsilon_{z,p,gen}^{CO_2} \times  \omega_{t} \times \Theta_{y,t,z} \right)  \hspace{1 cm}  \forall p \in \mathcal{P}^{CO_2}_{gen}
\end{aligned}\]</div><p>Note that the generator-side rate-based constraint can be used to represent a fee-rebate (``feebate&#39;&#39;) system: the dirty generators that emit above the bar (<span>$\epsilon_{z,p,gen}^{maxCO_2}$</span>) have to buy emission allowances from the emission regulator in the region <span>$z$</span> where they are located; in the same vein, the clean generators get rebates from the emission regulator at an emission allowance price being the dual variable of the emissions rate constraint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/model/policies/co2_cap.jl#L1-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.energy_share_requirement-Tuple{JuMP.Model,Dict,Dict}" href="#GenX.energy_share_requirement-Tuple{JuMP.Model,Dict,Dict}"><code>GenX.energy_share_requirement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">energy_share_requirement(EP::Model, inputs::Dict, setup::Dict)</code></pre><p>This function establishes constraints that can be flexibily applied to define alternative forms of policies that require generation of a minimum quantity of megawatt-hours from a set of qualifying resources, such as renewable portfolio standard (RPS) or clean electricity standard (CES) policies prevalent in different jurisdictions. These policies usually require that the annual MWh generation from a subset of qualifying generators has to be higher than a pre-specified percentage of load from qualifying zones.</p><p>The implementation allows for user to define one or multiple RPS/CES style minimum energy share constraints, where each constraint can cover different combination of model zones to mimic real-world policy implementation (e.g. multiple state policies, multiple RPS ``tiers&#39;&#39; or overlapping RPS and CES policies). The number of energy share requirement constraints is specified by the user by the value of the GenX settings parameter &#39;&#39;&#39;EnergyShareRequirement&#39;&#39;&#39; (this value should be an integer &gt;=0). For each constraint <span>$p \in \mathcal{P}^{ESR}$</span>, we define a subset of zones <span>$z \in \mathcal{Z}^{ESR}_{p} \subset \mathcal{Z}$</span> that are eligible for trading renewable/clean energy credits to meet the corresponding renewable/clean energy requirement. </p><p>For each energy share requirement constraint <span>$p \in \mathcal{P}^{ESR}$</span>, we specify the share of total demand in each eligible model zone, <span>$z \in \mathcal{Z}^{ESR}_{p}$</span>, that must be served by qualifying resources, <span>$\mathcal{G}_{p}^{ESR} \subset \mathcal{G}$</span>:</p><div>\[\begin{aligned} \allowdisplaybreaks
&amp;\sum_{z \in \mathcal{Z}_{p}^{ESR}} \sum_{y \in \mathcal{G}_{p}^{ESR}} \sum_{t \in \mathcal{T}} (\omega_{t} \times  \Theta_{y,z,t}) \geq  \sum_{z \in \mathcal{Z}^{ESR}_{p}} \sum_{t \in \mathcal{T}} (\mu_{p,z}^{ESR} \times \omega_{t} \times D_{z,t}) + \notag \\
&amp;\sum_{y \in \mathcal{O}} \sum_{z \in \mathcal{Z}^{ESR}_{p}} \sum_{t \in \mathcal{T}} \left(\mu_{p,z}^{ESR} \times \omega_{t} \times (\Pi_{y,z,t} - \Theta_{y,z,t}) \right) \hspace{1 cm}  \forall p \in \mathcal{P}^{ESR} 
\end{aligned}\]</div><p>The final term in the summation above adds roundtrip storage losses to the total load to which the energy share obligation applies. This term is included in the constraint if the GenX setup parameter &#39;&#39;&#39;StorageLosses=1&#39;&#39;&#39;. If &#39;&#39;&#39;StorageLosses=0&#39;&#39;&#39;, this term is removed from the constraint. In practice, most existing renewable portfolio standard policies do not account for storage losses when determining energy share requirements. However, with 100\% RPS or CES policies enacted in several jurisdictions, policy makers may wish to include storage losses in the minimum energy share, as otherwise there will be a difference between total generation and total load that will permit continued use of non-qualifying resources (e.g. emitting generators).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/model/policies/energy_share_requirement.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.get_absolute_extreme-NTuple{4,Any}" href="#GenX.get_absolute_extreme-NTuple{4,Any}"><code>GenX.get_absolute_extreme</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_absolute_extreme(DF, statKey, col_names, ConstCols)</code></pre><p>Get the period index of the single timestep with the minimum or maximum load or capacity factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/time_domain_reduction/time_domain_reduction.jl#L351-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.get_extreme_period" href="#GenX.get_extreme_period"><code>GenX.get_extreme_period</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_extreme_period(DF, GDF, profKey, typeKey, statKey,
   ConstCols, load_col_names, solar_col_names, wind_col_names)</code></pre><p>Identify extreme week by specification of profile type (Load, PV, Wind), measurement type (absolute (timestep with min/max value) vs. integral (period with min/max summed value)), and statistic (minimum or maximum). I.e., the user could want the hour with the most load across the whole system to be included among the extreme periods. They would select &quot;Load&quot;, &quot;System, &quot;Absolute, and &quot;Max&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/time_domain_reduction/time_domain_reduction.jl#L286-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.get_integral_extreme-NTuple{4,Any}" href="#GenX.get_integral_extreme-NTuple{4,Any}"><code>GenX.get_integral_extreme</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_integral_extreme(GDF, statKey, col_names, ConstCols)</code></pre><p>Get the period index with the minimum or maximum load or capacity factor summed over the period.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/time_domain_reduction/time_domain_reduction.jl#L332-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.get_worst_period_idx-Tuple{Any}" href="#GenX.get_worst_period_idx-Tuple{Any}"><code>GenX.get_worst_period_idx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_worst_period_idx(R)</code></pre><p>Get the index of the period that is farthest from its representative period by Euclidean distance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/time_domain_reduction/time_domain_reduction.jl#L168-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.investment_charge-Tuple{JuMP.Model,Dict}" href="#GenX.investment_charge-Tuple{JuMP.Model,Dict}"><code>GenX.investment_charge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">investment_charge(EP::Model, inputs::Dict)

This function defines the expressions and constraints keeping track of total available storage charge capacity across all resources as well as constraints on capacity retirements. The function also adds investment and fixed O\&amp;M related costs related to charge capacity to the objective function.

The total capacity of each resource is defined as the sum of the existing capacity plus the newly invested capacity minus any retired capacity (Eq. \ref{eq:totalchargecap}).

```math
\begin{aligned}\allowdisplaybreaks
\label{eq:totalchargecap}
&amp; \Delta^{total,charge}_{y,z} =(\overline{\Delta^{charge}_{y,z}}+\Omega^{charge}_{y,z}-\Delta^{charge}_{y,z}) \forall y \in \mathcal{O}^{asym}, z \in \mathcal{Z}
\end{aligned}
```

One cannot retire more capacity than existing capacity. 
```math
\begin{aligned} \allowdisplaybreaks
\label{eq:ccapub}
&amp;\Delta^{charge}_{y,z} \leq \overline{\Delta^{charge}_{y,z}}
	\hspace{4 cm}  \forall y \in \mathcal{O}^{asym}, z \in \mathcal{Z} 
\end{aligned}

For resources where $\overline{\Omega_{y,z}^{charge}}$ and $\underline{\Omega_{y,z}^{charge}}$ is defined, then we impose constraints on minimum (Eq. \ref{eq:mincap}) and maximum power capacity (Eq. \ref{eq:maxcap}).
```math
\begin{aligned} \allowdisplaybreaks
\label{eq:minccap}
&amp; \Delta^{total,charge}_{y,z} \leq \overline{\Omega}^{charge}_{y,z}
	\hspace{4 cm}  \forall y \in \mathcal{O}^{asym}, z \in \mathcal{Z} \\
\label{eq:maxccap}
&amp; \Delta^{total,charge}_{y,z}  \geq \underline{\Omega}^{charge}_{y,z}
	\hspace{4 cm}  \forall y \in \mathcal{O}^{asym}, z \in \mathcal{Z}
\end{aligned}
```

In addition, this function adds investment and fixed O\&amp;M related costs related to charge capacity to the objective function:
```math
\begin{aligned} \allowdisplaybreaks
&amp; 	\sum_{y \in \mathcal{O}^{asym} } \sum_{z \in \mathcal{Z}} 
	\left( (\pi^{INVEST,charge}_{y,z} \times    \Omega^{charge}_{y,z}) 
	+ (\pi^{FOM,charge}_{y,z} \times  \Delta^{total,charge}_{y,z})\right)
\end{aligned}
```</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/model/resources/storage/investment_charge.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.investment_energy-Tuple{JuMP.Model,Dict}" href="#GenX.investment_energy-Tuple{JuMP.Model,Dict}"><code>GenX.investment_energy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">investment_energy(EP::Model, inputs::Dict)

This function defines the expressions and constraints keeping track of total available storage charge capacity across all resources as well as constraints on capacity retirements. The function also adds investment and fixed O\&amp;M related costs related to charge capacity to the objective function.

The total capacity of each resource is defined as the sum of the existing capacity plus the newly invested capacity minus any retired capacity (Eq. \ref{eq:totalchargecap}).
```math
\begin{aligned}\allowdisplaybreaks
\label{eq:totalenergycap}
&amp; \Delta^{total,energy}_{y,z} =(\overline{\Delta^{energy}_{y,z}}+\Omega^{energy}_{y,z}-\Delta^{energy}_{y,z}) \forall y \in \mathcal{O}, z \in \mathcal{Z}  
\end{aligned}
```

One cannot retire more capacity than existing capacity. 
```math
\begin{aligned} \allowdisplaybreaks
\label{eq:pcapub}
&amp;\Delta^{energy}_{y,z} \leq \overline{\Delta^{energy}_{y,z}}
	\hspace{4 cm}  \forall y \in \mathcal{O}, z \in \mathcal{Z}   
\label{eq:ccapub}
\end{aligned}

For resources where $\overline{\Omega_{y,z}^{energy}}$ and $\underline{\Omega_{y,z}^{energy}}$ is defined, then we impose constraints on minimum (Eq. \ref{eq:mincap}) and maximum power capacity (Eq. \ref{eq:maxcap}).
```math
\begin{aligned} \allowdisplaybreaks
\label{eq:minecap}
&amp; \Delta^{total,energy}_{y,z} \leq \overline{\Omega}^{energy}_{y,z}
	\hspace{4 cm}  \forall y \in \mathcal{O}, z \in \mathcal{Z} \\
\label{eq:maxecap}
&amp; \Delta^{total,energy}_{y,z}  \geq \underline{\Omega}^{energy}_{y,z}
	\hspace{4 cm}  \forall y \in \mathcal{O}, z \in \mathcal{Z}
\end{aligned}
```

In addition, this function adds investment and fixed O\&amp;M related costs related to charge capacity to the objective function:
```math
\begin{aligned} \allowdisplaybreaks
&amp; 	\sum_{y \in \mathcal{O} } \sum_{z \in \mathcal{Z}} 
	\left( (\pi^{INVEST,energy}_{y,z} \times    \Omega^{energy}_{y,z}) 
	+ (\pi^{FOM,energy}_{y,z} \times  \Delta^{total,energy}_{y,z})\right)
\end{aligned}
```</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/model/resources/storage/investment_energy.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.load_cap_reserve_margin-Tuple{Dict,AbstractString,AbstractString,Dict,DataFrames.DataFrame}" href="#GenX.load_cap_reserve_margin-Tuple{Dict,AbstractString,AbstractString,Dict,DataFrames.DataFrame}"><code>GenX.load_cap_reserve_margin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_cap_reserve_margin(setup::Dict, path::AbstractString, sep::AbstractString, inputs_crm::Dict, network_var::DataFrame)</code></pre><p>Function for reading input parameters related to planning reserve margin constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/load_inputs/load_cap_reserve_margin.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.load_co2_cap-Tuple{Dict,AbstractString,AbstractString,Dict}" href="#GenX.load_co2_cap-Tuple{Dict,AbstractString,AbstractString,Dict}"><code>GenX.load_co2_cap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_co2_cap(setup::Dict, path::AbstractString, sep::AbstractString, inputs_co2::Dict)</code></pre><p>Function for reading input parameters related to CO<span>$_2$</span> emissions cap constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/load_inputs/load_co2_cap.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.load_data-Tuple{Dict,AbstractString,AbstractString,Dict}" href="#GenX.load_data-Tuple{Dict,AbstractString,AbstractString,Dict}"><code>GenX.load_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_data(setup::Dict, path::AbstractString, sep::AbstractString, inputs_load::Dict)</code></pre><p>Function for reading input parameters related to electricity load (demand)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/load_inputs/load_load_data.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.load_energy_share_requirement-Tuple{Dict,AbstractString,AbstractString,Dict}" href="#GenX.load_energy_share_requirement-Tuple{Dict,AbstractString,AbstractString,Dict}"><code>GenX.load_energy_share_requirement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_energy_share_requirement(setup::Dict, path::AbstractString, sep::AbstractString, inputs_ESR::Dict)</code></pre><p>Function for reading input parameters related to mimimum energy share requirement constraints (e.g. renewable portfolio standard or clean electricity standard policies)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/load_inputs/load_energy_share_requirement.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.load_fuels_data-Tuple{Dict,AbstractString,AbstractString,Dict}" href="#GenX.load_fuels_data-Tuple{Dict,AbstractString,AbstractString,Dict}"><code>GenX.load_fuels_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_fuels_data(setup::Dict, path::AbstractString, sep::AbstractString, inputs_fuel::Dict)</code></pre><p>Function for reading input parameters related to fuel costs and CO<span>$_2$</span> content of fuels</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/load_inputs/load_fuels_data.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.load_generators_data-Tuple{Dict,AbstractString,AbstractString,Dict,Dict,Dict}" href="#GenX.load_generators_data-Tuple{Dict,AbstractString,AbstractString,Dict,Dict,Dict}"><code>GenX.load_generators_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_generators_data(setup::Dict, path::AbstractString, sep::AbstractString, inputs_gen::Dict, fuel_costs::Dict, fuel_CO2::Dict)</code></pre><p>Function for reading input parameters related to electricity generators (plus storage and flexible demand resources)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/load_inputs/load_generators_data.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.load_generators_variability-Tuple{Dict,AbstractString,AbstractString,Dict}" href="#GenX.load_generators_variability-Tuple{Dict,AbstractString,AbstractString,Dict}"><code>GenX.load_generators_variability</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_generators_variability(setup::Dict, path::AbstractString, sep::AbstractString, inputs_genvar::Dict)</code></pre><p>Function for reading input parameters related to hourly maximum capacity factors for all generators (plus storage and flexible demand resources)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/load_inputs/load_generators_variability.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.load_minimum_capacity_requirement-Tuple{AbstractString,AbstractString,Dict,Dict}" href="#GenX.load_minimum_capacity_requirement-Tuple{AbstractString,AbstractString,Dict,Dict}"><code>GenX.load_minimum_capacity_requirement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_minimum_capacity_requirement(path::AbstractString,sep::AbstractString, inputs::Dict, setup::Dict)</code></pre><p>Function for reading input parameters related to mimimum capacity requirement constraints (e.g. technology specific deployment mandates)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/load_inputs/load_minimum_capacity_requirement.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.load_network_data-Tuple{Dict,AbstractString,AbstractString,Dict}" href="#GenX.load_network_data-Tuple{Dict,AbstractString,AbstractString,Dict}"><code>GenX.load_network_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_network_data(setup::Dict, path::AbstractString, sep::AbstractString, inputs_nw::Dict)</code></pre><p>Function for reading input parameters related to the electricity transmission network</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/load_inputs/load_network_data.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.load_period_map-Tuple{Dict,AbstractString,AbstractString,Dict}" href="#GenX.load_period_map-Tuple{Dict,AbstractString,AbstractString,Dict}"><code>GenX.load_period_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_period_map(setup::Dict,path::AbstractString,sep::AbstractString, inputs::Dict)</code></pre><p>Function for reading input parameters related to mapping of representative time periods to full chronological time series</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/load_inputs/load_period_map.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.load_reserves-Tuple{Dict,AbstractString,AbstractString,Dict}" href="#GenX.load_reserves-Tuple{Dict,AbstractString,AbstractString,Dict}"><code>GenX.load_reserves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_reserves(setup::Dict,path::AbstractString,sep::AbstractString, inputs_res::Dict)</code></pre><p>Function for reading input parameters related to frequency regulation and operating reserve requirements</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/load_inputs/load_reserves.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.long_duration_storage-Tuple{JuMP.Model,Dict}" href="#GenX.long_duration_storage-Tuple{JuMP.Model,Dict}"><code>GenX.long_duration_storage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">long_duration_storage(EP::Model, inputs::Dict)</code></pre><p>This function creates variables and constraints enabling modeling of long duration storage resources when modeling representative time periods.</p><p><strong>Storage inventory balance at beginning of each representative period</strong></p><p>The constraints in this section are used to approximate the behavior of long-duration energy storage technologies when approximating annual grid operations by modeling operations over representative periods. Previously, the state of charge balance for storage (as defined in <code>storage_all()</code>) assumed that state of charge at the beginning and end of each representative period has to be the same. In other words, the amount of energy built up or consumed by storage technology <span>$o$</span> in zone <span>$z$</span> over the representative period <span>$m$</span>, <span>$\Delta Q_{o,z,m} = 0$</span>. This assumption implicitly excludes the possibility of transferring energy from one representative period to the other which could be cost-optimal when the capital cost of energy storage capacity is relatively small. To model long-duration energy storage using representative periods, we replace the state of charge equation, such that the first term on the right hand side accounts for change in storage inventory associated with representative period <span>$m$</span> (<span>$\Delta Q_{o,z,m}$</span>), which could be positive (net accumulation) or negative (net reduction). </p><div>\[\begin{aligned}\allowdisplaybreaks
&amp; \Gamma_{o,z,(m-1)\times \tau^{period}+1 } =\left(1-\eta_{o,z}^{loss}\right)\times \left(\Gamma_{o,z,m\times \tau^{period}} -\Delta Q_{o,z,m}\right) - \notag \\
&amp;\frac{1}{\eta_{o,z}^{discharge}}\Theta_{o,z,(m-1)\times \tau^{period}+1} + \eta_{o,z}^{charge}\Pi_{o,z,(m-1)\times \tau^{period}+1} \quad \forall o \in \mathcal{O}^{LDES}, z \in \mathcal{Z}, m \in \mathcal{M}
\label{eq:SoCBalLDES}
\end{aligned}\]</div><p>By definition <span>$\mathcal{T}^{start}=\{\left(m-1\right) \times \tau^{period}+1 | m \in \mathcal{M}\}$</span>, which implies that this constraint is defined for all values of <span>$t \in T^{start}$</span>. </p><p><strong>Storage inventory change input periods</strong></p><p>We need additional variables and constraints to approximate energy exchange between representative periods, while accounting for their chronological occurence in the original input time series data and the possibility that two representative periods may not be adjacent to each other (Fig. \ref{fig:LDESmodel}). To implement this, we introduce a new variable <span>$Q_{o,z, n}$</span> that models inventory of storage technology <span>$o \in O$</span> in zone <span>$z$</span> in each \textit{input} period <span>$n \in \mathcal{N}$</span>. Additionally we define a function mapping, <span>$f: n \rightarrow m$</span>, that uniquely maps each input period <span>$n$</span> to its corresponding representative period <span>$m$</span>. This mapping is available as an output of the process used to identify representative periods (E.g. k-means clustering \cite{Mallapragada2018}). </p><p>\begin{figure}[h] \caption{Modeling inter-period energy exchange via long-duration storage when using representative period temporal resolution to approximate annual grid operations} \includegraphics[width=\textwidth]{LDES_approach.png} \label{fig:LDESmodel} \end{figure}</p><p>The following two equations define the storage inventory at the beginning of each input period <span>$n+1$</span> as the sum of storage inventory at begining of previous input period <span>$n$</span> plus change in storage inventory for that period. The latter is approximated by the change in storage inventory in the corresponding representative period, identified per the mapping <span>$f(n)$</span>.  The second constraint relates the storage level of the last input period, <span>$|N|$</span>, with the storage level at the beginning of the first input period. Finally, if the input period is also a representative period, then a third constraint enforces that initial storage level estimated by the intra-period storage balance constraint should equal the initial storage level estimated from the inter-period storage balance constraints.</p><p>%note that <span>$|N|$</span> refers to the last modeled period. Here,</p><div>\[\begin{aligned} \allowdisplaybreaks
&amp; Q_{o,z,n+1} = Q_{o,z,n} + \Delta Q_{o,z,f(n)}
\quad \forall  o \in \mathcal{O}^{LDES}, z \in \mathcal{Z}, n \in \mathcal{N}\setminus\{|N|\}
\label{eq:LDESBal1}
\end{aligned}

\begin{aligned} \allowdisplaybreaks
&amp; Q_{o,z,1} = Q_{o,z,|N|} + \Delta Q_{o,z,f(|N|)}
\quad \forall  o \in \mathcal{O}^{LDES}, z \in \mathcal{Z}, n = |N|
\label{eq:LDESBal2}
\end{aligned}

\begin{aligned} \allowdisplaybreaks
&amp; Q_{o,z,n} =\Gamma_{o,z,f(n)\times \tau^{period}} - \Delta Q_{o,z,m}
\quad \forall  o \in \mathcal{O}^{LDES}, z \in \mathcal{Z}, n \in   \mathcal{N}^{rep}, 
\label{eq:LDESBal3}
\end{aligned}\]</div><p>Finally, the next constraint enforces that the initial storage level for each input period <span>$n$</span> must be less than the installed energy capacity limit. This constraint ensures that installed energy storage capacity is consistent with the state of charge during both the operational time periods <span>$t$</span> during each sample period <span>$m$</span> as well as at the start of each chronologically ordered input period <span>$n$</span> in the full annual time series.</p><div>\[\begin{aligned}
    Q_{o,z,n} \leq \Delta^{total, energy}_{o,z}
\quad \forall n \in \mathcal{N}, o \in \mathcal{O}^{LDES}
    \label{eq:LDESEcap}
\end{aligned}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/model/resources/storage/long_duration_storage.jl#L1-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.minimum_capacity_requirement-Tuple{JuMP.Model,Dict}" href="#GenX.minimum_capacity_requirement-Tuple{JuMP.Model,Dict}"><code>GenX.minimum_capacity_requirement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minimum_capacity_requirement(EP::Model, inputs::Dict)</code></pre><p>The minimum capacity requirement constraint allows for modeling minimum deployment of a certain technology or set of eligible technologies across the eligible model zones and can be used to mimic policies supporting specific technology build out (i.e. capacity deployment targets/mandates for storage, offshore wind, solar etc.). The default unit of the constraint is in MW. For each requirement <span>$p \in \mathcal{P}^{MinCapReq}$</span>, we model the policy with the following constraint. <code>math \begin{aligned} \sum_{y \in \mathcal{G} } \sum_{z \in \mathcal{Z} } \left( \epsilon_{y,z,p}^{MinCapReq} \times \Delta^{\text{total}}_{y,z} \right) \geq REQ_{p}^{MinCapReq} \hspace{1 cm}  \forall p \in \mathcal{P}^{MinCapReq} \end{aligned}</code> Note that <span>$\epsilon_{y,z,p}^{MinCapReq}$</span> is the eligiblity of a generator of technology <span>$y$</span> in zone <span>$z$</span> of requirement <span>$p$</span> and will be equal to <span>$1$</span> for eligible generators and will be zero for ineligible resources. The dual value of each minimum capacity constraint can be interpreted as the required payment (e.g. subsidy) per MW per year required to ensure adequate revenue for the qualifying resources.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/model/policies/minimum_capacity_requirement.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.must_run-Tuple{JuMP.Model,Dict}" href="#GenX.must_run-Tuple{JuMP.Model,Dict}"><code>GenX.must_run</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">must_run(EP::Model, inputs::Dict)</code></pre><p>This function defines the constraints for operation of `must-run&#39; or non-dispatchable resources, such as rooftop solar systems that do not receive dispatch signals, run-of-river hydroelectric facilities without the ability to spill water, or cogeneration systems that must produce a fixed quantity of heat in each time step. This resource type can also be used to model baseloaded or self-committed thermal generators that do not respond to economic dispatch.</p><p>For must-run resources (<span>$y\in \mathcal{MR}$</span>) output in each time period <span>$t$</span> must exactly equal the available capacity factor times the installed capacity, not allowing for curtailment. These resources are also not eligible for contributing to frequency regulation or operating reserve requirements. </p><div>\[\begin{aligned} \allowdisplaybreaks
\label{eq:mustruncapub}
	\Theta_{y,z,t} = \rho^{max}_{y,z,t}\times \Delta^{total}_{y,z} 
	\hspace{4 cm}  \forall y \in \mathcal{MR}, z \in \mathcal{Z},t \in \mathcal{T}
\end{aligned}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/model/resources/must_run/must_run.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.non_served_energy-Tuple{JuMP.Model,Dict}" href="#GenX.non_served_energy-Tuple{JuMP.Model,Dict}"><code>GenX.non_served_energy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">non_served_energy(EP::Model, inputs::Dict)</code></pre><p>This function defines the non-served energy/curtailed demand decision variable <span>$\Lambda_{s,t,z} \forall s \in \mathcal{S}, \forall t \in \mathcal{T}, z \in \mathcal{Z}$</span>, representing the total amount of demand curtailed in demand segment <span>$s$</span> at time period <span>$t$</span> in zone <span>$z$</span>. The first segment of non-served energy, <span>$s=1$</span>, is used to denote the cost of involuntary demand curtailment (e.g. emergency load shedding or rolling blackouts), specified as the value of <span>$n_{1}^{slope}$</span>. Additional segments, <span>$s \geq 2$</span> can be used to specify a segment-wise approximation of a price elastic demand curve, or segments of price-responsive curtailable loads (aka demand response). Each segment denotes a price/cost at which the segment of demand is willing to curtail consumption, <span>$n_{s}^{slope}$</span>, representing the marginal willingness to pay for electricity of this segment of demand (or opportunity cost incurred when demand is not served) and a maximum quantity of demand in this segment, <span>$n_{s}^{size}$</span>, specified as a share of demand in each zone in each time step, <span>$D_{t,z}.$</span> Note that the current implementation assumes demand segments are an equal share of hourly load in all zones.</p><p>This function defines contributions to the objective function from the cost of non-served energy/curtailed demand from all demand curtailment segments <span>$s \in \mathcal{S}$</span> over all time periods <span>$t \in \mathcal{T}$</span> and all zones <span>$z \in \mathcal{Z}$</span>:</p><div>\[\begin{aligned}
	Obj_{NSE} = 
	\sum_{s \in \mathcal{S} } \sum_{t \in \mathcal{T}} \sum_{z \in \mathcal{Z}}\omega_{t} \times n_{s}^{slope} \times \Lambda_{s,t,z}
\end{aligned}\]</div><p>Contributions to the power balance expression from non-served energy/curtailed demand from each demand segment <span>$s \in \mathcal{S}$</span> are also defined as:</p><div>\[\begin{aligned}
	PowerBal_{NSE} = 
	\sum_{s \in \mathcal{S} } \Lambda_{s,t,z}
		\hspace{4 cm}  \forall s \in \mathcal{S}, t \in \mathcal{T}
\end{aligned}\]</div><p><strong>Bounds on curtailable demand</strong></p><p>Demand curtailed in each segment of curtailable demands <span>$s \in \mathcal{S}$</span> cannot exceed maximum allowable share of demand:</p><div>\[\begin{aligned}
	\Lambda_{s,t,z} \leq (n_{s}^{size} \times D_{t,z})
	\hspace{4 cm}  \forall s \in \mathcal{S}, t \in \mathcal{T}, z\in \mathcal{Z}
\end{aligned}\]</div><p>Additionally, total demand curtailed in each time step cannot exceed total demand:</p><div>\[\begin{aligned}
	\sum_{s \in \mathcal{S} } \Lambda_{s,t,z} \leq D_{t,z}
	\hspace{4 cm}  \forall t \in \mathcal{T}, z\in \mathcal{Z}
\end{aligned}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/model/core/non_served_energy.jl#L1-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.parse_data-Tuple{Any}" href="#GenX.parse_data-Tuple{Any}"><code>GenX.parse_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parse_data(myinputs)</code></pre><p>Get load, solar, wind, and other curves from the input data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/time_domain_reduction/time_domain_reduction.jl#L94-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.reserves-Tuple{JuMP.Model,Dict,Int64}" href="#GenX.reserves-Tuple{JuMP.Model,Dict,Int64}"><code>GenX.reserves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reserves(EP::Model, inputs::Dict, UCommit::Int)</code></pre><p>This function sets up reserve decisions and constraints, using reserves_core() and reserves_contingency() functions. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/model/core/reserves.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.reserves_contingency-Tuple{JuMP.Model,Dict,Int64}" href="#GenX.reserves_contingency-Tuple{JuMP.Model,Dict,Int64}"><code>GenX.reserves_contingency</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reserves_contingency(EP::Model, inputs::Dict, UCommit::Int)</code></pre><p>This function establishes several different versions of contingency reserve requirement expression, <span>$CONTINGENCY$</span> used in the reserves_core() function below.</p><p>Contingency reserves represent requirements for upward ramping capability within a specified time frame to compensated for forced outages or unplanned failures of generators or transmission lines (e.g. N-1 contingencies). </p><p>There are three options for the <span>$Contingency$</span> expression, depending on user settings: </p><p>\begin{enumerate} \item a static contingency, in which the contingency requirement is set based on a fixed value (in MW) specified in the &#39;&#39;&#39;reserves.csv&#39;&#39;&#39; input file;  \item a dynamic contingency based on installed capacity decisions, in which the largest \textit{installed} generator is used to determine the contingency requirement for all time periods; and  \item dynamic unit commitment based contingency, in which the largest \textit{committed} generator in any time period is used to determine the contingency requirement in that time period.   \end{enumerate}</p><p>Note that the two dynamic contigencies are only available if unit commitment is being modeled.</p><p><strong>Static contingency</strong> Option 1 (static contingency) is expressed by the following constraint:</p><div>\[\begin{aligned}
	Contingency = \epsilon^{contingency}
	\label{eq:statconting}
\end{aligned}\]</div><p>where <span>$\epsilon^{contingency}$</span> is static contingency requirement in MWs.</p><p><strong>Dynamic capacity-based contingency</strong> Option 2 (dynamic capacity-based contingency) is expressed by the following constraints (Eqs. \ref{eq:dynamconting1} - \ref{eq:dynamconting3}):</p><div>\[\begin{aligned}
	Contingency \geq \Omega^{size}_{y,z} \times \alpha^{Contingency,Aux}_{y,z} \hspace{4cm} \forall y \in \mathcal{UC}, z \in \mathcal{Z} 
	\label{eq:dynamconting1}
\end{aligned}
\begin{aligned}
	\alpha^{Contingency,Aux}_{y,z} \leq \Delta^{\text{total}}_{y,z} \hspace{4cm} \forall y \in \mathcal{UC}, z \in \mathcal{Z} 
	\label{eq:dynamconting2}
\end{aligned}
\begin{aligned}
	\alpha^{Contingency,Aux}_{y,z} \geq M_y \times \Delta^{\text{total}}_{y,z} \hspace{4cm} \forall y \in \mathcal{UC}, z \in \mathcal{Z}
	\label{eq:dynamconting3}
\end{aligned}\]</div><p>where <span>$M_y$</span> is a `big M&#39; constant equal to the largest possible capacity that can be installed for generation cluster <span>$y$</span>, and <span>$\alpha^{Contingency,Aux}_{y,z} \in [0,1]$</span> is a binary auxiliary variable that is forced by the second and third equations above to be 1 if the total installed capacity <span>$\Delta^{\text{total}}_{y,z} &gt; 0$</span> for any generator <span>$y \in \mathcal{UC}$</span> and zone <span>$z$</span>, and can be 0 otherwise. Note that if the user specifies contingency option 2, and is also using the linear relaxation of unit commitment constraints, the capacity size parameter for units in the set <span>$\mathcal{UC}$</span> must still be set to a discrete unit size for this contingency to work as intended. </p><p><strong>Dynamic commitment-based contingency</strong> Option 3 (dynamic commitment-based contingency) is expressed by the following three sets of constraints (Eqs. \ref{eq:dynamconting4} - \ref{eq:dynamconting6}):</p><div>\[\begin{aligned}
	Contingency \geq \Omega^{size}_{y,z} \times Contingency\_Aux_{y,z,t} \hspace{4cm} \forall y \in \mathcal{UC}, z \in \mathcal{Z} 
	\label{eq:dynamconting4}
\end{aligned}
\begin{aligned}
	Contingency\_Aux_{y,z,t} \leq \nu_{y,z,t} \hspace{4cm} \forall y \in \mathcal{UC}, z \in \mathcal{Z} 
	\label{eq:dynamconting5}
\end{aligned}
\begin{aligned}
	Contingency\_Aux_{y,z,t} \geq M_y \times \nu_{y,z,t} \hspace{4cm} \forall y \in \mathcal{UC}, z \in \mathcal{Z}
	\label{eq:dynamconting6}
\end{aligned}\]</div><p>where <span>$M_y$</span> is a `big M&#39; constant equal to the largest possible capacity that can be installed for generation cluster <span>$y$</span>, and <span>$Contingency\_Aux_{y,z,t} \in [0,1]$</span> is a binary auxiliary variable that is forced by the second and third equations above to be 1 if the commitment state for that generation cluster <span>$\nu_{y,z,t} &gt; 0$</span> for any generator <span>$y \in \mathcal{UC}$</span> and zone <span>$z$</span> and time period <span>$t$</span>, and can be 0 otherwise. Note that this dynamic commitment-based contingency can only be specified if discrete unit commitment decisions are used (e.g. it will not work if relaxed unit commitment is used).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/model/core/reserves.jl#L23-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.rmse_score-Tuple{Any,Any}" href="#GenX.rmse_score-Tuple{Any,Any}"><code>GenX.rmse_score</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rmse_score(y_true, y_pred)</code></pre><p>Calculates Root Mean Square Error.</p><div>\[RMSE = \\sqrt{\\frac{1}{n}\\Sigma_{i=1}^{n}{\\Big(\\frac{d_i -f_i}{\\sigma_i}\\Big)^2}}\]</div><p>CITE: https://towardsdatascience.com/julia-for-data-science-how-to-build-linear-regression-from-scratch-with-julia-6d1521a00611</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/time_domain_reduction/time_domain_reduction.jl#L74-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.scale_weights" href="#GenX.scale_weights"><code>GenX.scale_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">scale_weights(W, H)</code></pre><p>Linearly scale weights W such that they sum to the desired number of timesteps (hours) H.</p><div>\[w_j \leftarrow H \cdot \frac{w_j}{\sum_i w_i} \: \: \: \forall w_j \in W\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/time_domain_reduction/time_domain_reduction.jl#L372-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.storage_asymmetric_reserves-Tuple{JuMP.Model,Dict}" href="#GenX.storage_asymmetric_reserves-Tuple{JuMP.Model,Dict}"><code>GenX.storage_asymmetric_reserves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">storage_asymmetric_reserves(EP::Model, inputs::Dict)</code></pre><p>Sets up variables and constraints specific to storage resources with asymmetric charge and discharge capacities when reserves are modeled. See <code>storage()</code> in <code>storage.jl</code> for description of constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/model/resources/storage/storage_asymmetric.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.storage_symmetric_reserves-Tuple{JuMP.Model,Dict}" href="#GenX.storage_symmetric_reserves-Tuple{JuMP.Model,Dict}"><code>GenX.storage_symmetric_reserves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">storage_symmetric_reserves(EP::Model, inputs::Dict)</code></pre><p>Sets up variables and constraints specific to storage resources with symmetric charge and discharge capacities when reserves are modeled. See <code>storage()</code> in <code>storage.jl</code> for description of constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/model/resources/storage/storage_symmetric.jl#L37-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.thermal_commit-Tuple{JuMP.Model,Dict,Int64}" href="#GenX.thermal_commit-Tuple{JuMP.Model,Dict,Int64}"><code>GenX.thermal_commit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">thermal_commit(EP::Model, inputs::Dict, Reserves::Int)</code></pre><p>This function defines the operating constraints for thermal power plants subject to unit commitment constraints on power plant start-ups and shut-down decision (<span>$y \in UC$</span>).</p><p>We model capacity investment decisions and commitment and cycling (start-up, shut-down) of thermal generators using the integer clustering technique developed in \cite{Palmintier2011, Palmintier2014}. In a typical binary unit commitment formulation, each unit is either on or off. With the clustered unit commitment formulation, one or more cluster(s) of similar generators are clustered by type and zone (typically using heat rate and fixed O\&amp;M cost to create clusters), and the integer commitment state variable for each cluster varies from zero to the number of units in the cluster, <span>$\frac{\Delta^{total}_{y,z}}{\Omega^{size}_{y,z}}$</span>. As discussed in \cite{Palmintier2014}, this approach replaces the large set of binary commitment decisions and associated constraints, which scale directly with the number of individual units, with a smaller set of integer commitment states and  constraints, one for each cluster <span>$y$</span>. The dimensionality of the problem thus scales with the number of units of a given type in each zone, rather than by the number of discrete units, significantly improving computational efficiency. However, this method entails the simplifying assumption that all clustered units have identical parameters (e.g., capacity size, ramp rates, heat rate) and that all committed units in a given time step <span>$t$</span> are operating at the same power output per unit.</p><p><strong>Power balance expression</strong></p><p>This function adds the sum of power generation from thermal units subject to unit commitment (<span>$\Theta_{y \in UC,t \in T,z \in Z}$</span>) to the power balance expression.</p><p><strong>Startup and shutdown events (thermal plant cycling)</strong></p><p>***Capacitated limits on unit commitment decision variables***</p><p>Thermal resources subject to unit commitment (<span>$y \in \mathcal{UC}$</span>) adhere to the following constraints on commitment states, startup events, and shutdown events, which limit each decision to be no greater than the maximum number of discrete units installed (as per the following three constraints):</p><div>\[\begin{aligned}
\label{eq:numclustermax1}
\nu_{y,z,t} \leq \frac{\Delta^{\text{total}}_{y,z}}{\Omega^{size}_{y,z}}
	\hspace{4cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}  
\end{aligned}
\label{eq:numclustermax2}
\begin{aligned}
\chi_{y,z,t} \leq \frac{\Delta^{\text{total}}_{y,z}}{\Omega^{size}_{y,z}}
	\hspace{4cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}  
\end{aligned}
\begin{aligned}
\label{eq:numclustermax3}
\zeta_{y,z,t} \leq \frac{\Delta^{\text{total}}_{y,z}}{\Omega^{size}_{y,z}}
	\hspace{4cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}  
\end{aligned}\]</div><p>(See Constraints 1-3 in the code)</p><p>where decision <span>$\nu_{y,z,t}$</span> designates the commitment state of generator cluster <span>$y$</span> in zone <span>$z$</span> at time <span>$t$</span>, decision <span>$\chi_{y,z,t}$</span> represents number of startup decisions, decision <span>$\zeta_{y,z,t}$</span> represents number of shutdown decisions, <span>$\Delta^{\text{total}}_{y,z}$</span> is the total installed capacity, and parameter <span>$\Omega^{size}_{y,z}$</span> is the unit size.</p><p>***Commitment state constraint linking start-up and shut-down decisions***</p><p>Additionally, the following constarint maintains the commitment state variable across time, <span>$\nu_{y,z,t}$</span>, as the sum of the commitment state in the prior, <span>$\nu_{y,z,t-1}$</span>, period plus the number of units started in the current period, <span>$\chi_{y,z,t}$</span>, less the number of units shut down in the current period, <span>$\zeta_{y,z,t}$</span>:</p><div>\[\begin{aligned} \allowdisplaybreaks
\label{eq:ucommitconstraintint}
&amp;\nu_{y,z,t} =\nu_{y,z,t-1} + \chi_{y,z,t} - \zeta_{y,z,t}
	\hspace{3.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}^{interior} \\
\label{eq:ucommitconstraintstart}
&amp;\nu_{y,z,t} =\nu_{y,z,t +\tau^{period}-1} + \chi_{y,z,t} - \zeta_{y,z,t}
	\hspace{3.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}^{start}
\end{aligned}\]</div><p>(See Constraint 4 in the code)</p><p>Like other time-coupling constraints, this constraint wraps around to link the commitment state in the first time step of the year (or each representative period), <span>$t \in \mathcal{T}^{start}$</span>, to the last time step of the year (or each representative period), <span>$t+\tau^{period}-1$</span>. </p><p><strong>Ramping constraints</strong></p><p>Thermal resources subject to unit commitment (<span>$y \in UC$</span>) adhere to the following ramping constraints on hourly changes in power output:</p><div>\[\begin{aligned}
\begin{aligned}
	\Theta_{y,z,t-1} - \Theta_{y,z,t} &amp;\leq  \kappa^{down}_{y,z} \cdot \Omega^{size}_{y,z} \cdot (\nu_{y,z,t} - \chi_{y,z,t}) &amp; \\[6pt]
	\qquad &amp; - \: \rho^{min}_{y,z} \cdot \Omega^{size}_{y,z} \cdot \chi_{y,z,t} &amp; \hspace{0.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}  \\[6pt]
	\qquad &amp; + \: \text{min}( \rho^{max}_{y,z,t}, \text{max}( \rho^{min}_{y,z}, \kappa^{down}_{y,z} ) ) \cdot \Omega^{size}_{y,z} \cdot \zeta_{y,z,t} &amp; 
\end{aligned}
\end{aligned}
\begin{aligned}
\begin{aligned}
	\Theta_{y,z,t} - \Theta_{y,z,t-1} &amp;\leq  \kappa^{up}_{y,z} \cdot \Omega^{size}_{y,z} \cdot (\nu_{y,z,t} - \chi_{y,z,t}) &amp; \\[6pt]
	\qquad &amp; + \: \text{min}( \rho^{max}_{y,z,t}, \text{max}( \rho^{min}_{y,z}, \kappa^{up}_{y,z} ) ) \cdot \Omega^{size}_{y,z} \cdot \chi_{y,z,t} &amp; \hspace{0.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T} \\[6pt]
	\qquad &amp; - \: \rho^{min}_{y,z} \cdot \Omega^{size}_{y,z} \cdot \zeta_{y,z,t} &amp;
\end{aligned}
\end{aligned}\]</div><p>(See Constraints 5-6 in the code)</p><p>where decision <span>$\Theta_{y,z,t}$</span> is the energy injected into the grid by technology <span>$y$</span> in zone <span>$z$</span> at time <span>$t$</span>, parameter <span>$\kappa_{y,z,t}^{up|down}$</span> is the maximum ramp-up or ramp-down rate as a percentage of installed capacity, parameter <span>$\rho_{y,z}^{min}$</span> is the minimum stable power output per unit of installed capacity, and parameter <span>$\rho_{y,z,t}^{max}$</span> is the maximum available generation per unit of installed capacity. These constraints account for the ramping limits for committed (online) units as well as faster changes in power enabled by units starting or shutting down in the current time step.</p><p><strong>Minimum and maximum power output</strong></p><p>If not modeling regulation and spinning reserves, thermal resources subject to unit commitment adhere to the following constraints that ensure power output does not exceed minimum and maximum feasible levels:</p><div>\[\begin{aligned}
	\Theta_{y,z,t} \geq \rho^{min}_{y,z} \times \Omega^{size}_{y,z} \times \nu_{y,z,t}
	\hspace{4cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}  
\end{aligned}
\begin{aligned}
	\Theta_{y,z,t} \leq \rho^{max}_{y,z,t} \time \Omega^{size}_{y,z} \times \nu_{y,z,t}
	\hspace{4cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</div><p>(See Constraints 7-8 the code)</p><p>If modeling reserves and regulation, these constraints are replaced by those established in this thermal<em>commit</em>reserves().</p><p><strong>Minimum and maximum up and down time</strong></p><p>Thermal resources subject to unit commitment adhere to the following constraints on the minimum time steps after start-up before a unit can shutdown again (minimum up time) and the minimum time steps after shut-down before a unit can start-up again (minimum down time):</p><div>\[\begin{aligned}
\label{eq:minuptime}
	\nu_{y,z,t} \geq \displaystyle \sum_{\hat{t} = t-\tau^{up}_{y,z}}^t \chi_{y,z,\hat{t}}
	\hspace{5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T} 
\end{aligned}
\begin{aligned}
\label{eq:mindowntime}
	\frac{\overline{\Delta_{y,z}} + \Omega_{y,z} - \Delta_{y,z}}{\Omega^{size}_{y,z}} -  \nu_{y,z,t} \geq \displaystyle \sum_{\hat{t} = t-\tau^{down}_{y,z}}^t \zeta_{y,z,\hat{t}}
	\hspace{1.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</div><p>(See Constraints 9-10 in the code)</p><p>where <span>$\tau_{y,z}^{up|down}$</span> is the minimum up or down time for units in generating cluster <span>$y$</span> in zone <span>$z$</span>.</p><p>Like with the ramping constraints, the minimum up and down constraint time also wrap around from the start of each time period to the end of each period.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/model/resources/thermal/thermal_commit.jl#L1-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.thermal_commit_reserves-Tuple{JuMP.Model,Dict}" href="#GenX.thermal_commit_reserves-Tuple{JuMP.Model,Dict}"><code>GenX.thermal_commit_reserves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">thermal_commit_reserves(EP::Model, inputs::Dict)</code></pre><p>This function is called by the thermal_commit() function when regulation and reserves constraints are active and defines reserve related constraints for thermal power plants subject to unit commitment constraints on power plant start-ups and shut-down decisions.</p><p><strong>Maximum contributions to frequency regulation and reserves</strong></p><p>When modeling frequency regulation and reserves contributions, thermal units subject to unit commitment adhere to the following constraints which limit the maximum contribution to regulation and reserves in each time step to a specified maximum fraction (<span>$,\upsilon^{rsv}_{y,z}$</span>) of the commitment capacity in that time step (<span>$(\Omega^{size}_{y,z} \cdot \nu_{y,z,t})$</span>):</p><div>\[\begin{aligned}
	f_{y,z,t} \leq \upsilon^{reg}_{y,z} \times \rho^{max}_{y,z,t} (\Omega^{size}_{y,z} \times \nu_{y,z,t}) \hspace{4cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T} 
\end{aligned}
\begin{aligned}
	r_{y,z,t} \leq \upsilon^{rsv}_{y,z} \times \rho^{max}_{y,z,t} (\Omega^{size}_{y,z} \times \nu_{y,z,t}) \hspace{4cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T} 
\end{aligned}\]</div><p>where <span>$f_{y,z,t}$</span> is the frequency regulation contribution limited by the maximum regulation contribution <span>$\upsilon^{reg}_{y,z}$</span>, and <span>$r_{y,z,t}$</span> is the reserves contribution limited by the maximum reserves contribution <span>$\upsilon^{rsv}_{y,z}$</span>. Limits on reserve contributions reflect the maximum ramp rate for the thermal resource in whatever time interval defines the requisite response time for the regulation or reserve products (e.g., 5 mins or 15 mins or 30 mins). These response times differ by system operator and reserve product, and so the user should define these parameters in a self-consistent way for whatever system context they are modeling.</p><p><strong>Minimum and maximum power output</strong></p><p>When modeling frequency regulation and spinning reserves contributions, thermal resources subject to unit commitment adhere to the following constraints that ensure the sum of power output and reserve and/or regulation contributions do not exceed minimum and maximum feasible power output:</p><div>\[\begin{aligned}
	\Theta_{y,z,t} - f_{y,z,t} \geq \rho^{min}_{y,z} \times Omega^{size}_{y,z} \times \nu_{y,z,t}
	\hspace{4cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T} 
\end{aligned}
\begin{aligned}
	\Theta_{y,z,t} + f_{y,z,t} + r_{y,z,t} \leq \rho^{max}_{y,z,t} \times \Omega^{size}_{y,z} \times \nu_{y,z,t}
	\hspace{3.2cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</div><p>Note there are multiple versions of these constraints in the code in order to avoid creation of unecessary constraints and decision variables for thermal units unable to provide regulation and/or reserves contributions due to input parameters (e.g. Reg<em>Max and/or RSV</em>Max = 0)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/model/resources/thermal/thermal_commit.jl#L256-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.thermal_no_commit-Tuple{JuMP.Model,Dict,Int64}" href="#GenX.thermal_no_commit-Tuple{JuMP.Model,Dict,Int64}"><code>GenX.thermal_no_commit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">thermal_no_commit(EP::Model, inputs::Dict, Reserves::Int)</code></pre><p>This function defines the operating constraints for thermal power plants NOT subject to unit commitment constraints on power plant start-ups and shut-down decisions (<span>$y \in H \setminus UC$</span>).</p><p><strong>Ramping limits</strong></p><p>Thermal resources not subject to unit commitment (<span>$y \in H \setminus UC$</span>) adhere instead to the following ramping limits on hourly changes in power output:</p><div>\[\begin{aligned}
	\Theta_{y,z,t-1} - \Theta_{y,z,t} \leq \kappa_{y,z}^{down} \Delta^{\text{total}}_{y,z} \hspace{3cm} \forall y \in \mathcal{H \setminus UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}  
\end{aligned}
\begin{aligned}
	\Theta_{y,z,t} - \Theta_{y,z,t-1} \leq \kappa_{y,z}^{up} \Delta^{\text{total}}_{y,z} \hspace{3.5cm} \forall y \in \mathcal{H \setminus UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</div><p>(See Constraints 1-2 in the code)</p><p>This set of time-coupling constraints wrap around to ensure the power output in the first time step of each year (or each representative period), <span>$t \in \mathcal{T}^{start}$</span>, is within the eligible ramp of the power output in the final time step of the year (or each representative period), <span>$t+\tau^{period}-1$</span>. </p><p><strong>Minimum and maximum power output</strong></p><p>When not modeling regulation and reserves, thermal units not subject to unit commitment decisions are bound by the following limits on maximum and minimum power output:</p><div>\[\begin{aligned}
	\Theta_{y,z,t} \geq \rho^{min}_{y,z} \times \Delta^{total}_{y,z}
	\hspace{4cm} \forall y \in \mathcal{H \setminus UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}  
\end{aligned}
\begin{aligned}
	\Theta_{y,z,t} \leq \rho^{max}_{y,z,t} \times \Delta^{total}_{y,z}
	\hspace{4cm} \forall y \in \mathcal{H \setminus UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</div><p>(See Constraints 3-4 in the code)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/model/resources/thermal/thermal_no_commit.jl#L1-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.thermal_no_commit_reserves-Tuple{JuMP.Model,Dict}" href="#GenX.thermal_no_commit_reserves-Tuple{JuMP.Model,Dict}"><code>GenX.thermal_no_commit_reserves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">	thermal_no_commit_reservesEP::Model, inputs::Dict)

This function is called by the thermal_no_commit() function when regulation and reserves constraints are active and defines reserve related constraints for thermal power plants not subject to unit commitment constraints on power plant start-ups and shut-down decisions.

**Maximum contributions to frequency regulation and reserves**

Thermal units not subject to unit commitment adhere instead to the following constraints on maximum reserve and regulation contributions:

```math
\begin{aligned}
	f_{y,z,t} \leq \upsilon^{reg}_{y,z} \times \rho^{max}_{y,z,t} \Delta^{\text{total}}_{y,z} \hspace{4cm} \forall y \in \mathcal{H \setminus UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}  
\end{aligned}
\begin{aligned}
	r_{y,z,t} \leq \upsilon^{rsv}_{y,z} \times \rho^{max}_{y,z,t} \Delta^{\text{total}}_{y,z} \hspace{4cm} \forall y \in \mathcal{H \setminus UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}  
\end{aligned}
```
where $f_{y,z,t}$ is the frequency regulation contribution limited by the maximum regulation contribution $\upsilon^{reg}_{y,z}$, and $r_{y,z,t}$ is the reserves contribution limited by the maximum reserves contribution $\upsilon^{rsv}_{y,z}$. Limits on reserve contributions reflect the maximum ramp rate for the thermal resource in whatever time interval defines the requisite response time for the regulation or reserve products (e.g., 5 mins or 15 mins or 30 mins). These response times differ by system operator and reserve product, and so the user should define these parameters in a self-consistent way for whatever system context they are modeling.

**Minimum and maximum power output**

When modeling regulation and spinning reserves, thermal units not subject to unit commitment are bound by the following limits on maximum and minimum power output:

```math
\begin{aligned}
	\Theta_{y,z,t} - f_{y,z,t} \geq \rho^{min}_{y,z} \times \Delta^{\text{total}}_{y,z}
	\hspace{3.5cm} \forall y \in \mathcal{H \setminus UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}  
\end{aligned}
\begin{aligned}
	\Theta_{y,z,t} + f_{y,z,t} + r_{y,z,t} \leq \rho^{max}_{y,z,t} \times \Delta^{\text{total}}_{y,z}
	\hspace{2.2cm} \forall y \in \mathcal{H \setminus UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}
```

Note there are multiple versions of these constraints in the code in order to avoid creation of unecessary constraints and decision variables for thermal units unable to provide regulation and/or reserves contributions due to input parameters (e.g. Reg_Max and/or RSV_Max = 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/model/resources/thermal/thermal_no_commit.jl#L102-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.transmission-Tuple{JuMP.Model,Dict,Int64,Int64}" href="#GenX.transmission-Tuple{JuMP.Model,Dict,Int64,Int64}"><code>GenX.transmission</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transmission(EP::Model, inputs::Dict, UCommit::Int, NetworkExpansion::Int)</code></pre><p>This function establishes decisions, expressions, and constraints related to transmission power flows between model zones and associated transmission losses (if modeled).</p><p>The function adds transmission reinforcement or construction costs to the objective function. Transmission reinforcement costs are equal to the sum across all lines of the product between the transmission reinforcement/construction cost, <span>$pi^{TCAP}_{l}$</span>, times the additional transmission capacity variable, <span>$\bigtriangleup\varphi^{max}_{l}$</span>. </p><div>\[\begin{aligned}\allowdisplaybreaks
&amp; \sum_{l \in \mathcal{L}}\left(\pi^{TCAP}_{l} \times \bigtriangleup\varphi^{max}_{l}\right)
\end{aligned}\]</div><p>Note that fixed O\&amp;M and replacement capital costs (depreciation) for existing transmission capacity is treated as a sunk cost and not included explicitly in the GenX objective function.</p><p>Power flow and transmission loss terms are also added to the power balance constraint for each zone:</p><div>\[\begin{aligned}\allowdisplaybreaks
&amp;	- \sum_{l\in \mathcal{L}}{(\varphi^{map}_{l,z} \times \Phi_{l,t})} - \frac{1}{2} \sum_{l\in \mathcal{L}}{(\varphi^{map}_{l,z} \times \beta_{l,t}(\cdot))}
\end{aligned}\]</div><p>Power flows, <span>$\Phi_{l,t}$</span>, on each line <span>$l$</span> into or out of a zone (defined by the network map <span>$\varphi^{map}_{l,z}$</span>), are considered in the demand balance equation for each zone. By definition, power flows leaving their reference zone are positive, thus the minus sign is used for this term. Losses due to power flows increase demand, and one-half of losses across a line linking two zones are attributed to each connected zone. The losses function <span>$\beta_{l,t}(\cdot)$</span> will depend on the configuration used to model losses (see below).</p><p><strong>Accounting for Transmission and Network Expansion Between Zones</strong></p><p>Transmission flow constraints are modeled using a `<code>transport method,&#39;&#39; where power flow, $\Phi_{l,t}$, on each line (or more likely a</code>path&#39; aggregating flows across multiple parallel lines) is constrained to be less than or equal to the line&#39;s maximum power transfer capacity, <span>$\varphi^{max}_{l}$</span>, plus any transmission capacity added on that line (for lines eligible for expansion in the set <span>$\mathcal{E}$</span>). The additional transmission capacity, <span>$\bigtriangleup\varphi^{max}_{l} $, is constrained by a maximum allowed reinforcement, $\overline{\bigtriangleup\varphi^{max}_{l}}$</span>, for each line <span>$l \in \mathcal{E}$</span>.</p><div>\[\begin{aligned}\allowdisplaybreaks
	% trasmission constraints	
	&amp;-\varphi^{max}_{l} \leq  \Phi_{l,t} \leq \varphi^{max}_{l} , &amp;\quad \forall l \in (\mathcal{L} \setminus \mathcal{E} ),\forall t  \in \mathcal{T}\\ 
	% trasmission expansion	
	&amp;-(\varphi^{max}_{l} + \bigtriangleup\varphi^{max}_{l} ) \leq  \Phi_{l,t} \leq (\varphi^{max}_{l} + \bigtriangleup\varphi^{max}_{l} ) , &amp;\quad \forall l \in \mathcal{E},\forall t  \in \mathcal{T}\\
	&amp; \bigtriangleup\varphi^{max}_{l}  \leq \overline{\bigtriangleup\varphi^{max}_{l}}, &amp;\quad \forall l \in \mathcal{E}
\end{aligned}\]</div><p><strong>Accounting for Transmission Losses</strong></p><p>Transmission losses due to power flows can be accounted for in three different ways. The first option is to neglect losses entirely, setting the value of the losses function to zero for all lines at all hours. The second option is to assume that losses are a fixed percentage, <span>$\varphi^{loss}_{l}$</span>, of the magnitude of power flow on each line, <span>$\mid \Phi_{l,t} \mid$</span> (e.g., losses are a linear function of power flows). Finally, the third option is to calculate losses, <span>$\ell_{l,t}$</span>, by approximating a quadratic-loss function of power flow across the line using a piecewise-linear function with total number of segments equal to the size of the set <span>$\mathcal{M}$</span>.</p><div>\[\begin{aligned}\allowdisplaybreaks
%configurable losses formulation
	&amp; \beta_{l,t}(\cdot) = \begin{cases} 0 &amp; \text{if~} \text{losses.~0} \\ \\ \varphi^{loss}_{l}\times \mid \Phi_{l,t} \mid &amp; \text{if~} \text{losses.~1} \\ \\ \ell_{l,t} &amp;\text{if~} \text{losses.~2} \end{cases}, &amp;\quad \forall l \in \mathcal{L},\forall t  \in \mathcal{T} 
\end{aligned}\]</div><p>For the second option, an absolute value approximation is utilized to calculate the magnitude of the power flow on each line (reflecting the fact that negative power flows for a line linking nodes <span>$i$</span> and <span>$j$</span> represents flows from node <span>$j$</span> to <span>$i$</span> and causes the same magnitude of losses as an equal power flow from <span>$i$</span> to <span>$j$</span>). This absolute value function is linearized such that the flow in the line must be equal to the subtraction of the auxiliary variable for flow in the positive direction, <span>$\Phi^{+}_{l,t}$</span>, and the auxiliary variable for flow in the negative direction, <span>$\Phi^{+}_{l,t}$</span>, of the line. Then, the magnitude of the flow is calculated as the sum of the two auxiliary variables. The sum of positive and negative directional flows are also constrained by the maximum line flow capacity. </p><div>\[\begin{aligned}\allowdisplaybreaks
% trasmission losses simple
	&amp;\Phi_{l,t} =  \Phi^{+}_{l,t}  - \Phi^{-}_{l,t}, &amp;\quad \forall l \in \mathcal{L}, \forall t  \in \mathcal{T}\\ 
	&amp;\mid \Phi_{l,t} \mid =  \Phi^{+}_{l,t}  + \Phi^{-}_{l,t}, &amp;\quad \forall l \in \mathcal{L}, \forall t  \in \mathcal{T}\\ 
	&amp;\Phi^{+}_{l,t}  + \Phi^{-}_{l,t} \leq \varphi^{max}_{l}, &amp;\quad \forall l \in \mathcal{L}, \forall t  \in \mathcal{T}
\end{aligned}\]</div><p>If discrete unit commitment decisions are modeled, ``phantom losses&#39;&#39; can be observed wherein the auxiliary variables for flows in both directions (<span>$\Phi^{+}_{l,t}$</span> and <span>$\Phi^{-}_{l,t}$</span>) are both increased to produce increased losses so as to avoid cycling a thermal generator and incurring start-up costs or opportunity costs related to minimum down times. This unrealistic behavior can be eliminated via inclusion of additional constraints and a set of auxiliary binary variables, <span>$ON^{+}_{l,t} \in {0,1} \forall l \in \mathcal{L}$</span>. Then the following additional constraints are created:</p><div>\[\begin{aligned}\allowdisplaybreaks
	\Phi^{+}_{l,t} \leq TransON^{+}_{l,t},  &amp;\quad \forall l \in \mathcal{L}, \forall t  \in \mathcal{T}\\ 
	\Phi^{-}_{l,t} \leq (\varphi^{max}_{l} + \bigtriangleup\varphi^{max}_{l}) -TransON^{+}_{l,t}, &amp;\quad  \forall l \in \mathcal{L}, \forall t  \in \mathcal{T}
\end{aligned}\]</div><p>where <span>$TransON^{+}_{l,t}$</span> is a continuous variable, representing the product of the binary variable <span>$ON^{+}_{l,t}$</span> and the expression, <span>$(\varphi^{max}_{l} + \bigtriangleup\varphi^{max}_{l})$</span>. This product cannot be defined explicitly, since it will lead to a bilinear expression involving two variables. Instead, we enforce this definition via the Glover&#39;s Linearization as shown below (also referred McCormick Envelopes constraints for bilinear expressions, which is exact when one of the variables is binary).</p><div>\[\begin{aligned}\allowdisplaybreaks
	TransON^{+}_{l,t} \leq  (\varphi^{max}_{l} + \overline{\bigtriangleup\varphi^{max}_{l}}) \times TransON^{+}_{l,t},  &amp;\quad \forall l \in \mathcal{L}, \forall t  \in \mathcal{T}\\ 
	TransON^{+}_{l,t} \leq  (\varphi^{max}_{l} + \bigtriangleup\varphi^{max}_{l}),  &amp;\quad \forall l \in \mathcal{L}, \forall t  \in \mathcal{T}\\ 
	TransON^{+}_{l,t} \leq (\varphi^{max}_{l} + \bigtriangleup\varphi^{max}_{l}) - (\varphi^{max}_{l} + \overline{\bigtriangleup\varphi^{max}_{l}}) \times(1- TransON^{+}_{l,t}),  &amp;\quad \forall l \in \mathcal{L}, \forall t  \in \mathcal{T}\
\end{aligned}\]</div><p>These constraints permit only the positive \textit{or} negative auxiliary flow variables to be non-zero at a given time period, not both.</p><p>For the third option, losses are calculated as a piecewise-linear approximation of a quadratic function of power flows. In order to do this, we represent the absolute value of the line flow variable by the sum of positive stepwise flow variables (<span>$\S^{+}_{m,l,t}, \S^{-}_{m,l,t}$</span>), associated with each partition of line losses computed using the corresponding linear expressions. This can be understood as a segmentwise linear fitting (or first order approximation) of the quadratic losses function. The first constraint below computes the losses a the accumulated sum of losses for each linear stepwise segment of the approximated quadratic function, including both positive domain and negative domain segments. A second constraint ensures that the stepwise variables do not exceed the maximum size per segment. The slope and maximum size for each segment are calculated as per the method in \cite{Zhang2013}.</p><div>\[\begin{aligned}\allowdisplaybreaks
	% losses constraints
	&amp; \ell_{l,t} = \frac{\varphi^{ohm}_{l}}{(\varphi^{volt}_{l})^2}\bigg( \sum_{m \in \mathcal{M}}( S^{+}_{m,l}\times \S^{+}_{m,l,t} + S^{-}_{m,l}\times \S^{-}_{m,l,t}) \bigg), &amp;\quad \forall l \in \mathcal{L}, \forall t  \in \mathcal{T} \notag\\
	&amp; \text{\quad Where:}\notag\\
	&amp;  \quad S^{+}_{m,l} = \frac{2+4 \times \sqrt{2}\times (m-1)}{1+\sqrt{2} \times (2 \times M-1)} (\varphi^{max}_{l} + \overline{\bigtriangleup\varphi^{max}_{l}}) &amp;\quad \forall m \in [1 \colon M], l \in \mathcal{L}  \notag\\
	&amp; \quad S^{-}_{m,l} = \frac{2+4 \times \sqrt{2}\times (m-1)}{1+\sqrt{2} \times (2 \times M-1)} (\varphi^{max}_{l} + \overline{\bigtriangleup\varphi^{max}_{l}}) &amp;\quad \forall m \in [1 \colon M], l \in \mathcal{L}\\
	&amp; \notag\\
	&amp;\S^{+}_{m,l,t}, \S^{-}_{m,l,t} &lt;= \overline{\S_{m,l}} &amp;\quad \forall m \in [1:M], l \in \mathcal{L}, t \in \mathcal{T} \notag\\
	&amp; \text{\quad Where:} \notag\\
	&amp; \quad \overline{\S_{l,z}} =  \begin{cases} \frac{(1+\sqrt{2})}{1+\sqrt{2} \times (2 \times M-1)}  (\varphi^{max}_{l} + \overline{\bigtriangleup\varphi^{max}_{l}}) &amp; \text{if~} \text{m=1} \\ \\  \frac{2 \times \sqrt{2} }{1+\sqrt{2} \times (2 \times M-1)} (\varphi^{max}_{l} + \overline{\bigtriangleup\varphi^{max}_{l}}) &amp; \text{if~} \text{m $&gt;$ 1} \end{cases}, &amp;
\end{aligned}\]</div><p>Next, a constraint ensures that the sum of auxiliary segment variables (<span>$m \geq 1$</span>) minus the ``zero&quot; segment (which allows values to go into the negative domain) from both positive and negative domains must total the actual power flow across the line, and a constraint ensures that the sum of negative and positive flows do not exceed the maximum flow for the line.</p><div>\[\begin{aligned}\allowdisplaybreaks
	&amp;\sum_{m \in [1:M]} (\S^{+}_{m,l,t}) - \S^{+}_{0,l,t} =  \Phi_{l,t}, &amp;\quad \forall l \in \mathcal{L}, \forall t  \in \mathcal{T}\\  
	&amp;\sum_{m \in [1:M]} (\S^{-}_{m,l,t}) - \S^{-}_{0,l,t}  =  - \Phi_{l,t} 
\end{aligned}\]</div><p>As with losses option 2, this segment-wise approximation of a quadratic loss function also permits <span>$phantom losses&#39;&#39; to avoid cycling thermal units when discrete unit commitment decisions are modeled. In this case, the additional constraints below are also added to ensure that auxiliary segments variables do not exceed maximum value per segment and that they are filled in order; i.e., one segment cannot be non-zero unless prior segment is at its maximum value. Binary constraints deal with absolute value of power flow on each line. If the flow is positive, $\S^{+}_{0,l,t}$ must be zero; if flow is negative, $\S^{+}_{0,l,t}$ must be positive and takes on value of the full negative flow, forcing all $\S^{+}_{m,l,t}$ other segments ($m \geq 1$) to be zero. Conversely, if the flow is negative, $\S^{-}_{0,l,t}$ must be zero; if flow is positive, $\S^{-}_{0,l,t}$ must be positive and takes on value of the full positive flow, forcing all $\S^{-}_{m,l,t}$ other segments ($m \geq 1$) to be zero. Requiring segments to fill in sequential order and binary variables to ensure variables reflect the actual direction of power flows are both necessary to eliminate$</span>phantom losses&#39;&#39; from the solution. These constraints and binary decisions are ommited if the model is fully linear.</p><div>\[\begin{aligned}\allowdisplaybreaks
	&amp;\S^{+}_{m,l,t} &lt;=    \overline{\S_{m,l}} \times ON^{+}_{m,l,t}, &amp;\quad \forall m \in [1:M], \forall l \in \mathcal{L}, \forall t  \in \mathcal{T}\\
	&amp;\S^{-}_{m,l,t} &lt;=    \overline{\S_{m,l}} \times ON^{-}_{m,l,t},  &amp;\quad \forall m \in[1:M], \forall l \in \mathcal{L}, \forall t  \in \mathcal{T}\\ 
	&amp;\S^{+}_{m,l,t} \geq ON^{+}_{m+1,l,t} \times \overline{\S_{m,l}}, &amp;\quad \forall m \in [1:M], \forall l \in \mathcal{L}, \forall t  \in \mathcal{T}\\
	&amp;\S^{-}_{m,l,t} \geq ON^{-}_{m+1,l,t} \times \overline{\S_{m,l}} , &amp;\quad \forall m \in [1:M], \forall l \in \mathcal{L}, \forall t  \in \mathcal{T}\\
	&amp;\S^{+}_{0,l,t} \leq \varphi^{max}_{l} \times (1- ON^{+}_{1,l,t}), &amp;\quad \forall l \in \mathcal{L}, \forall t  \in \mathcal{T}\\  
	&amp;\S^{-}_{0,l,t} \leq \varphi^{max}_{l} \times (1- ON^{-}_{1,l,t}), &amp;\quad \forall l \in \mathcal{L}, \forall t  \in \mathcal{T}  
\end{aligned}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/model/core/transmission.jl#L1-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.ucommit-Tuple{JuMP.Model,Dict,Int64}" href="#GenX.ucommit-Tuple{JuMP.Model,Dict,Int64}"><code>GenX.ucommit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ucommit(EP::Model, inputs::Dict, UCommit::Int)</code></pre><p>This function creates decision variables and cost expressions associated with thermal plant unit commitment or start-up and shut-down decisions (cycling on/off)</p><p><strong>Unit commitment decision variables:</strong></p><p>This function defines the following decision variables:</p><div>\[\nu_{y,t,z}\]</div><p>designates the commitment state of generator cluster <span>$y$</span> in zone <span>$z$</span> at time <span>$t$</span>;  <span>$\chi_{y,t,z}$</span> represents number of startup decisions in cluster <span>$y$</span> in zone <span>$z$</span> at time <span>$t$</span>; <span>$\zeta_{y,t,z}$</span> represents number of shutdown decisions in cluster <span>$y$</span> in zone <span>$z$</span> at time <span>$t$</span>.</p><p>**Cost expressions:*</p><p>The total cost of start-ups across all generators subject to unit commitment (<span>$y \in UC$</span>) and all time periods, t is expressed as:</p><div>\[\begin{aligned}
	C^{start} = \sum_{y \in UC, t \in T} \omega_t \times start\_cost_{y} \times \chi_{y,t}
\end{aligned}\]</div><p>The sum of start-up costs is added to the objective function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/model/core/ucommit.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.write_capacity-Tuple{AbstractString,AbstractString,Dict,Dict,JuMP.Model}" href="#GenX.write_capacity-Tuple{AbstractString,AbstractString,Dict,Dict,JuMP.Model}"><code>GenX.write_capacity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_capacity(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model))</code></pre><p>Function for writing the diferent capacities for the different generation technologies (starting capacities or, existing capacities, retired capacities, and new-built capacities)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/write_outputs/write_capacity.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.write_charge-Tuple{AbstractString,AbstractString,Dict,Dict,JuMP.Model}" href="#GenX.write_charge-Tuple{AbstractString,AbstractString,Dict,Dict,JuMP.Model}"><code>GenX.write_charge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_charge(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for writing the charging energy values of the different storage technologies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/write_outputs/write_charge.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.write_costs-Tuple{AbstractString,AbstractString,Dict,Dict,JuMP.Model}" href="#GenX.write_costs-Tuple{AbstractString,AbstractString,Dict,Dict,JuMP.Model}"><code>GenX.write_costs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_costs(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for writing the costs pertaining to the objective function (fixed, variable O &amp; M etc.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/write_outputs/write_costs.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.write_curtailment-Tuple{AbstractString,AbstractString,Dict,Dict,JuMP.Model}" href="#GenX.write_curtailment-Tuple{AbstractString,AbstractString,Dict,Dict,JuMP.Model}"><code>GenX.write_curtailment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_curtailment(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for writing the curtailment values of the different variable renewable resources.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/write_outputs/write_curtailment.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.write_power-Tuple{AbstractString,AbstractString,Dict,Dict,JuMP.Model}" href="#GenX.write_power-Tuple{AbstractString,AbstractString,Dict,Dict,JuMP.Model}"><code>GenX.write_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_power(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for writing the different values of power generated by the different technologies in operation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/write_outputs/write_power.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.write_status-Tuple{AbstractString,AbstractString,Dict,JuMP.Model}" href="#GenX.write_status-Tuple{AbstractString,AbstractString,Dict,JuMP.Model}"><code>GenX.write_status</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_status(path::AbstractString, sep::AbstractString, inputs::Dict, EP::Model)</code></pre><p>Function for writing the final solve status of the optimization problem solved</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/write_outputs/write_status.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenX.write_storage-Tuple{AbstractString,AbstractString,Dict,Dict,JuMP.Model}" href="#GenX.write_storage-Tuple{AbstractString,AbstractString,Dict,Dict,JuMP.Model}"><code>GenX.write_storage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_storage(path::AbstractString, sep::AbstractString, inputs::Dict,setup::Dict, EP::Model)</code></pre><p>Function for writing the capacities of different storage technologies, including hydro reservoir, flexible storage tech etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenXProject/GenX/blob/9cfff9b092dad9a507b0ea507664f4bc338b4634/src/write_outputs/write_storage.jl#L1-L5">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="load-inputs.html">Load Inputs »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 24 May 2021 11:00">Monday 24 May 2021</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
