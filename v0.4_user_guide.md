# Porting a module from GenX v0.3.6 to GenX v0.4.0

This guide is intended to help you port a module from GenX v0.3.6 to GenX v0.4.0. It is not a complete guide, but it should cover some of the most common changes. If you encounter any issues, please contact Luca Bonaldo. Another useful resource is the [`Working with GenX resources`](https://genxproject.github.io/GenX.jl/dev/developer_guide/#Working-with-GenX-resources) section of the GenX documentation. 

## New folder structure
To update the folder structure of your case to the new GenX v0.4.0 format, you can use the `split_generators_data.jl` script that can be found [here](https://github.com/lbonaldo/GenX/tree/release/0.4.0_user_guide/split_generators_data).

The new folder structure should look like this:
```
MyCase
│ 
├── settings
│   ├── genx_settings.yml           # GenX settings
│   ├── [solver_name]_settings.yml  # Solver settings
│   ├── multi_stage_settings.yml    # Multi-stage settings
│   └── time_domain_reduction.yml   # Time-domain clustering settings
│ 
├── system
│   ├── Demand_data.csv
│   ├── Fuel_data.csv
│   ├── Generators_variability.csv
│   ├── Operational_reserves.csv
│   └── Network.csv
│ 
├── policies
│   ├── CO2_cap.csv
|   ├── Maximum_capacity_requirement.csv
│   ├── Minimum_capacity_requirement.csv
│   ├── Capacity_reserve_margin.csv
│   └── Energy_share_requirement.csv
│ 
├── resources
│   ├── Thermal.csv
│   ├── Storage.csv
│   ├── Vre.csv
|   ├── [other_resource_files].csv
│   ├── Hydro.csv
│   └── policy_assignments
|       ├── Resource_minimum_capacity_requirement.csv
│       ├── Resource_maximum_capacity_requirement.csv
│       ├── Resource_capacity_reserve_margin.csv
│       └── Resource_energy_share_requirement.csv
│
└── Run.jl
```
**Note**:
Each folder name is lowercase. 

## Update a new GenX module or .jl file
For additional information, please refer to the [`Working with GenX resources`](https://genxproject.github.io/GenX.jl/dev/developer_guide/#Working-with-GenX-resources) section of the GenX documentation.

In GenX v0.4.0, each resource has its own `.jl` file, and therefore its own columns/attributes. Inside the code, the resources are contained in `inputs["RESOURCES"]`.

If you need to access a specific attribute of a resource, for example the `inv_cost_per_mwyr`, we recommend that you
use one of the functions defined in the `resource.jl` file. However, if you are creating a new column/attribute for your new module, we recommend that you create a small function and place it at the top of your module or in the `resource.jl` file. This function should take the resource as an argument and returns the attribute and a default value if the attribute is not present. 

For example:
```julia
# this is already defined in the resource.jl file
inv_cost_per_mwyr(r::AbstractResource) = get(r, :inv_cost_per_mwyr, 0.0)
# new column 
my_new_column(r::AbstractResource) = get(r, :my_new_column, my_default_value)
```

### Example of changes
-  `dfGen = inputs["dfGen"]` -> `gen = inputs["RESOURCES"]`
-  `dfGen[y, :Existing_Cap_MW]` -> `existing_cap_mw(gen[y])` (single resource)
-  `dfGen[!, :Existing_Cap_MW]` -> `existing_cap_mw.(gen)` (broadcasting to all resources)
-  `dfGen[dfGen[!, :Zone].==z, :R_ID]` -> `resources_in_zone_by_rid(gen,z)`

Policy tags (e.g., `MaxCapTag_1`, `MinCapTag_2`):
-  `dfGen[dfGen[!, Symbol("MaxCapTag_$maxcap")] .== 1, :R_ID]` -> `ids_with_policy(gen, max_cap, tag=1)`

### Example of changes in a new GenX module
```julia
# GenX v0.3.6
dfGen = inputs["dfGen"]

@expression(EP, my_expr1[y in 1:G], dfGen[y,:Existing_Cap_MW])
@expression(EP, my_expr2[y=1:G,t=1:T], (inputs["omega"][t]*(dfGen[y,:Var_OM_Cost_per_MWh]*vP[y,t])))
@expression(EP, my_expr3[z in 1:Z], sum(dfGen[y, :my_new_column]) for y in dfGen[dfGen[!, :Zone].==z, :R_ID])

zones = dfGen[!, :Zone]

# GenX v0.4.0
gen = inputs["RESOURCES"]
my_new_column(r::AbstractResource) = get(r, :my_new_column, my_default_value)

@expression(EP, my_expr1[y in 1:G], existing_cap_mw(gen[y]))
@expression(EP, my_expr2[y=1:G,t=1:T], (inputs["omega"][t] * (var_om_cost_per_mwh(gen[y]) * vP[y,t])))
@expression(EP, my_expr3[z in 1:Z], sum(my_new_column(gen[y]) for y in resources_in_zone_by_rid(gen,z)))

zones = zone_id.(gen)
```

